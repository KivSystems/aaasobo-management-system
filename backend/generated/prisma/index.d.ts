
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Instructor
 * 
 */
export type Instructor = $Result.DefaultSelection<Prisma.$InstructorPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model ClassAttendance
 * 
 */
export type ClassAttendance = $Result.DefaultSelection<Prisma.$ClassAttendancePayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model RecurringClass
 * 
 */
export type RecurringClass = $Result.DefaultSelection<Prisma.$RecurringClassPayload>
/**
 * Model RecurringClassAttendance
 * 
 */
export type RecurringClassAttendance = $Result.DefaultSelection<Prisma.$RecurringClassAttendancePayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model InstructorSchedule
 * 
 */
export type InstructorSchedule = $Result.DefaultSelection<Prisma.$InstructorSchedulePayload>
/**
 * Model InstructorSlot
 * 
 */
export type InstructorSlot = $Result.DefaultSelection<Prisma.$InstructorSlotPayload>
/**
 * Model InstructorAbsence
 * 
 */
export type InstructorAbsence = $Result.DefaultSelection<Prisma.$InstructorAbsencePayload>
/**
 * Model SystemStatus
 * 
 */
export type SystemStatus = $Result.DefaultSelection<Prisma.$SystemStatusPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Child
 * 
 */
export type Child = $Result.DefaultSelection<Prisma.$ChildPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Status: {
  booked: 'booked',
  completed: 'completed',
  canceledByCustomer: 'canceledByCustomer',
  canceledByInstructor: 'canceledByInstructor',
  pending: 'pending',
  rebooked: 'rebooked',
  declined: 'declined'
};

export type Status = (typeof Status)[keyof typeof Status]

}

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Instructors
 * const instructors = await prisma.instructor.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Instructors
   * const instructors = await prisma.instructor.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.instructor`: Exposes CRUD operations for the **Instructor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructors
    * const instructors = await prisma.instructor.findMany()
    * ```
    */
  get instructor(): Prisma.InstructorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classAttendance`: Exposes CRUD operations for the **ClassAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassAttendances
    * const classAttendances = await prisma.classAttendance.findMany()
    * ```
    */
  get classAttendance(): Prisma.ClassAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringClass`: Exposes CRUD operations for the **RecurringClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringClasses
    * const recurringClasses = await prisma.recurringClass.findMany()
    * ```
    */
  get recurringClass(): Prisma.RecurringClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recurringClassAttendance`: Exposes CRUD operations for the **RecurringClassAttendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecurringClassAttendances
    * const recurringClassAttendances = await prisma.recurringClassAttendance.findMany()
    * ```
    */
  get recurringClassAttendance(): Prisma.RecurringClassAttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instructorSchedule`: Exposes CRUD operations for the **InstructorSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstructorSchedules
    * const instructorSchedules = await prisma.instructorSchedule.findMany()
    * ```
    */
  get instructorSchedule(): Prisma.InstructorScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instructorSlot`: Exposes CRUD operations for the **InstructorSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstructorSlots
    * const instructorSlots = await prisma.instructorSlot.findMany()
    * ```
    */
  get instructorSlot(): Prisma.InstructorSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instructorAbsence`: Exposes CRUD operations for the **InstructorAbsence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstructorAbsences
    * const instructorAbsences = await prisma.instructorAbsence.findMany()
    * ```
    */
  get instructorAbsence(): Prisma.InstructorAbsenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemStatus`: Exposes CRUD operations for the **SystemStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemStatuses
    * const systemStatuses = await prisma.systemStatus.findMany()
    * ```
    */
  get systemStatus(): Prisma.SystemStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.child`: Exposes CRUD operations for the **Child** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Children
    * const children = await prisma.child.findMany()
    * ```
    */
  get child(): Prisma.ChildDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Instructor: 'Instructor',
    Customer: 'Customer',
    Class: 'Class',
    ClassAttendance: 'ClassAttendance',
    Plan: 'Plan',
    Subscription: 'Subscription',
    RecurringClass: 'RecurringClass',
    RecurringClassAttendance: 'RecurringClassAttendance',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    Schedule: 'Schedule',
    Event: 'Event',
    InstructorSchedule: 'InstructorSchedule',
    InstructorSlot: 'InstructorSlot',
    InstructorAbsence: 'InstructorAbsence',
    SystemStatus: 'SystemStatus',
    Admin: 'Admin',
    Child: 'Child'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "instructor" | "customer" | "class" | "classAttendance" | "plan" | "subscription" | "recurringClass" | "recurringClassAttendance" | "verificationToken" | "passwordResetToken" | "schedule" | "event" | "instructorSchedule" | "instructorSlot" | "instructorAbsence" | "systemStatus" | "admin" | "child"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Instructor: {
        payload: Prisma.$InstructorPayload<ExtArgs>
        fields: Prisma.InstructorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findFirst: {
            args: Prisma.InstructorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          findMany: {
            args: Prisma.InstructorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          create: {
            args: Prisma.InstructorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          createMany: {
            args: Prisma.InstructorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          delete: {
            args: Prisma.InstructorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          update: {
            args: Prisma.InstructorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          deleteMany: {
            args: Prisma.InstructorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstructorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>[]
          }
          upsert: {
            args: Prisma.InstructorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorPayload>
          }
          aggregate: {
            args: Prisma.InstructorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructor>
          }
          groupBy: {
            args: Prisma.InstructorGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      ClassAttendance: {
        payload: Prisma.$ClassAttendancePayload<ExtArgs>
        fields: Prisma.ClassAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          findFirst: {
            args: Prisma.ClassAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          findMany: {
            args: Prisma.ClassAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>[]
          }
          create: {
            args: Prisma.ClassAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          createMany: {
            args: Prisma.ClassAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>[]
          }
          delete: {
            args: Prisma.ClassAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          update: {
            args: Prisma.ClassAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          deleteMany: {
            args: Prisma.ClassAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>[]
          }
          upsert: {
            args: Prisma.ClassAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassAttendancePayload>
          }
          aggregate: {
            args: Prisma.ClassAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassAttendance>
          }
          groupBy: {
            args: Prisma.ClassAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<ClassAttendanceCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      RecurringClass: {
        payload: Prisma.$RecurringClassPayload<ExtArgs>
        fields: Prisma.RecurringClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          findFirst: {
            args: Prisma.RecurringClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          findMany: {
            args: Prisma.RecurringClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>[]
          }
          create: {
            args: Prisma.RecurringClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          createMany: {
            args: Prisma.RecurringClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>[]
          }
          delete: {
            args: Prisma.RecurringClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          update: {
            args: Prisma.RecurringClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          deleteMany: {
            args: Prisma.RecurringClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>[]
          }
          upsert: {
            args: Prisma.RecurringClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassPayload>
          }
          aggregate: {
            args: Prisma.RecurringClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringClass>
          }
          groupBy: {
            args: Prisma.RecurringClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringClassCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringClassCountAggregateOutputType> | number
          }
        }
      }
      RecurringClassAttendance: {
        payload: Prisma.$RecurringClassAttendancePayload<ExtArgs>
        fields: Prisma.RecurringClassAttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecurringClassAttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecurringClassAttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          findFirst: {
            args: Prisma.RecurringClassAttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecurringClassAttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          findMany: {
            args: Prisma.RecurringClassAttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>[]
          }
          create: {
            args: Prisma.RecurringClassAttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          createMany: {
            args: Prisma.RecurringClassAttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RecurringClassAttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>[]
          }
          delete: {
            args: Prisma.RecurringClassAttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          update: {
            args: Prisma.RecurringClassAttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          deleteMany: {
            args: Prisma.RecurringClassAttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecurringClassAttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RecurringClassAttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>[]
          }
          upsert: {
            args: Prisma.RecurringClassAttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecurringClassAttendancePayload>
          }
          aggregate: {
            args: Prisma.RecurringClassAttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecurringClassAttendance>
          }
          groupBy: {
            args: Prisma.RecurringClassAttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecurringClassAttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecurringClassAttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<RecurringClassAttendanceCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      InstructorSchedule: {
        payload: Prisma.$InstructorSchedulePayload<ExtArgs>
        fields: Prisma.InstructorScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          findFirst: {
            args: Prisma.InstructorScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          findMany: {
            args: Prisma.InstructorScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>[]
          }
          create: {
            args: Prisma.InstructorScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          createMany: {
            args: Prisma.InstructorScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>[]
          }
          delete: {
            args: Prisma.InstructorScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          update: {
            args: Prisma.InstructorScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          deleteMany: {
            args: Prisma.InstructorScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstructorScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>[]
          }
          upsert: {
            args: Prisma.InstructorScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSchedulePayload>
          }
          aggregate: {
            args: Prisma.InstructorScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructorSchedule>
          }
          groupBy: {
            args: Prisma.InstructorScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorScheduleCountAggregateOutputType> | number
          }
        }
      }
      InstructorSlot: {
        payload: Prisma.$InstructorSlotPayload<ExtArgs>
        fields: Prisma.InstructorSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          findFirst: {
            args: Prisma.InstructorSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          findMany: {
            args: Prisma.InstructorSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>[]
          }
          create: {
            args: Prisma.InstructorSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          createMany: {
            args: Prisma.InstructorSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>[]
          }
          delete: {
            args: Prisma.InstructorSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          update: {
            args: Prisma.InstructorSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          deleteMany: {
            args: Prisma.InstructorSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstructorSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>[]
          }
          upsert: {
            args: Prisma.InstructorSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorSlotPayload>
          }
          aggregate: {
            args: Prisma.InstructorSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructorSlot>
          }
          groupBy: {
            args: Prisma.InstructorSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorSlotCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorSlotCountAggregateOutputType> | number
          }
        }
      }
      InstructorAbsence: {
        payload: Prisma.$InstructorAbsencePayload<ExtArgs>
        fields: Prisma.InstructorAbsenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructorAbsenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructorAbsenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          findFirst: {
            args: Prisma.InstructorAbsenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructorAbsenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          findMany: {
            args: Prisma.InstructorAbsenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>[]
          }
          create: {
            args: Prisma.InstructorAbsenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          createMany: {
            args: Prisma.InstructorAbsenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstructorAbsenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>[]
          }
          delete: {
            args: Prisma.InstructorAbsenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          update: {
            args: Prisma.InstructorAbsenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          deleteMany: {
            args: Prisma.InstructorAbsenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstructorAbsenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstructorAbsenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>[]
          }
          upsert: {
            args: Prisma.InstructorAbsenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstructorAbsencePayload>
          }
          aggregate: {
            args: Prisma.InstructorAbsenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstructorAbsence>
          }
          groupBy: {
            args: Prisma.InstructorAbsenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstructorAbsenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructorAbsenceCountArgs<ExtArgs>
            result: $Utils.Optional<InstructorAbsenceCountAggregateOutputType> | number
          }
        }
      }
      SystemStatus: {
        payload: Prisma.$SystemStatusPayload<ExtArgs>
        fields: Prisma.SystemStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findFirst: {
            args: Prisma.SystemStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          findMany: {
            args: Prisma.SystemStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          create: {
            args: Prisma.SystemStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          createMany: {
            args: Prisma.SystemStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          delete: {
            args: Prisma.SystemStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          update: {
            args: Prisma.SystemStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          deleteMany: {
            args: Prisma.SystemStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>[]
          }
          upsert: {
            args: Prisma.SystemStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemStatusPayload>
          }
          aggregate: {
            args: Prisma.SystemStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemStatus>
          }
          groupBy: {
            args: Prisma.SystemStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SystemStatusCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Child: {
        payload: Prisma.$ChildPayload<ExtArgs>
        fields: Prisma.ChildFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChildFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChildFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findFirst: {
            args: Prisma.ChildFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChildFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          findMany: {
            args: Prisma.ChildFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          create: {
            args: Prisma.ChildCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          createMany: {
            args: Prisma.ChildCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChildCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          delete: {
            args: Prisma.ChildDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          update: {
            args: Prisma.ChildUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          deleteMany: {
            args: Prisma.ChildDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChildUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChildUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>[]
          }
          upsert: {
            args: Prisma.ChildUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChildPayload>
          }
          aggregate: {
            args: Prisma.ChildAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChild>
          }
          groupBy: {
            args: Prisma.ChildGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChildGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChildCountArgs<ExtArgs>
            result: $Utils.Optional<ChildCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    instructor?: InstructorOmit
    customer?: CustomerOmit
    class?: ClassOmit
    classAttendance?: ClassAttendanceOmit
    plan?: PlanOmit
    subscription?: SubscriptionOmit
    recurringClass?: RecurringClassOmit
    recurringClassAttendance?: RecurringClassAttendanceOmit
    verificationToken?: VerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    schedule?: ScheduleOmit
    event?: EventOmit
    instructorSchedule?: InstructorScheduleOmit
    instructorSlot?: InstructorSlotOmit
    instructorAbsence?: InstructorAbsenceOmit
    systemStatus?: SystemStatusOmit
    admin?: AdminOmit
    child?: ChildOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type InstructorCountOutputType
   */

  export type InstructorCountOutputType = {
    classes: number
    instructorAbsences: number
    instructorSchedules: number
    recurringClasses: number
  }

  export type InstructorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | InstructorCountOutputTypeCountClassesArgs
    instructorAbsences?: boolean | InstructorCountOutputTypeCountInstructorAbsencesArgs
    instructorSchedules?: boolean | InstructorCountOutputTypeCountInstructorSchedulesArgs
    recurringClasses?: boolean | InstructorCountOutputTypeCountRecurringClassesArgs
  }

  // Custom InputTypes
  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorCountOutputType
     */
    select?: InstructorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeCountInstructorAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorAbsenceWhereInput
  }

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeCountInstructorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorScheduleWhereInput
  }

  /**
   * InstructorCountOutputType without action
   */
  export type InstructorCountOutputTypeCountRecurringClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    children: number
    classes: number
    subscription: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CustomerCountOutputTypeCountChildrenArgs
    classes?: boolean | CustomerCountOutputTypeCountClassesArgs
    subscription?: boolean | CustomerCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    classAttendance: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classAttendance?: boolean | ClassCountOutputTypeCountClassAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAttendanceWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    subscription: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | PlanCountOutputTypeCountSubscriptionArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    class: number
    recurringClass: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | SubscriptionCountOutputTypeCountClassArgs
    recurringClass?: boolean | SubscriptionCountOutputTypeCountRecurringClassArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountRecurringClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassWhereInput
  }


  /**
   * Count Type RecurringClassCountOutputType
   */

  export type RecurringClassCountOutputType = {
    classes: number
    recurringClassAttendance: number
  }

  export type RecurringClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | RecurringClassCountOutputTypeCountClassesArgs
    recurringClassAttendance?: boolean | RecurringClassCountOutputTypeCountRecurringClassAttendanceArgs
  }

  // Custom InputTypes
  /**
   * RecurringClassCountOutputType without action
   */
  export type RecurringClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassCountOutputType
     */
    select?: RecurringClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecurringClassCountOutputType without action
   */
  export type RecurringClassCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
  }

  /**
   * RecurringClassCountOutputType without action
   */
  export type RecurringClassCountOutputTypeCountRecurringClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassAttendanceWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    Schedule: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Schedule?: boolean | EventCountOutputTypeCountScheduleArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type InstructorScheduleCountOutputType
   */

  export type InstructorScheduleCountOutputType = {
    slots: number
  }

  export type InstructorScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slots?: boolean | InstructorScheduleCountOutputTypeCountSlotsArgs
  }

  // Custom InputTypes
  /**
   * InstructorScheduleCountOutputType without action
   */
  export type InstructorScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorScheduleCountOutputType
     */
    select?: InstructorScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstructorScheduleCountOutputType without action
   */
  export type InstructorScheduleCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorSlotWhereInput
  }


  /**
   * Count Type ChildCountOutputType
   */

  export type ChildCountOutputType = {
    classAttendance: number
    recurringClassAttendance: number
  }

  export type ChildCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classAttendance?: boolean | ChildCountOutputTypeCountClassAttendanceArgs
    recurringClassAttendance?: boolean | ChildCountOutputTypeCountRecurringClassAttendanceArgs
  }

  // Custom InputTypes
  /**
   * ChildCountOutputType without action
   */
  export type ChildCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChildCountOutputType
     */
    select?: ChildCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChildCountOutputType without action
   */
  export type ChildCountOutputTypeCountClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAttendanceWhereInput
  }

  /**
   * ChildCountOutputType without action
   */
  export type ChildCountOutputTypeCountRecurringClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassAttendanceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Instructor
   */

  export type AggregateInstructor = {
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  export type InstructorAvgAggregateOutputType = {
    id: number | null
  }

  export type InstructorSumAggregateOutputType = {
    id: number | null
  }

  export type InstructorMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    classURL: string | null
    icon: string | null
    nickname: string | null
    meetingId: string | null
    passcode: string | null
    createdAt: Date | null
    birthdate: Date | null
    favoriteFood: string | null
    hobby: string | null
    lifeHistory: string | null
    messageForChildren: string | null
    skill: string | null
    workingTime: string | null
    terminationAt: Date | null
    updatedAt: Date | null
    isNative: boolean | null
  }

  export type InstructorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    classURL: string | null
    icon: string | null
    nickname: string | null
    meetingId: string | null
    passcode: string | null
    createdAt: Date | null
    birthdate: Date | null
    favoriteFood: string | null
    hobby: string | null
    lifeHistory: string | null
    messageForChildren: string | null
    skill: string | null
    workingTime: string | null
    terminationAt: Date | null
    updatedAt: Date | null
    isNative: boolean | null
  }

  export type InstructorCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    classURL: number
    icon: number
    nickname: number
    meetingId: number
    passcode: number
    createdAt: number
    birthdate: number
    favoriteFood: number
    hobby: number
    lifeHistory: number
    messageForChildren: number
    skill: number
    workingTime: number
    terminationAt: number
    updatedAt: number
    isNative: number
    _all: number
  }


  export type InstructorAvgAggregateInputType = {
    id?: true
  }

  export type InstructorSumAggregateInputType = {
    id?: true
  }

  export type InstructorMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    classURL?: true
    icon?: true
    nickname?: true
    meetingId?: true
    passcode?: true
    createdAt?: true
    birthdate?: true
    favoriteFood?: true
    hobby?: true
    lifeHistory?: true
    messageForChildren?: true
    skill?: true
    workingTime?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
  }

  export type InstructorMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    classURL?: true
    icon?: true
    nickname?: true
    meetingId?: true
    passcode?: true
    createdAt?: true
    birthdate?: true
    favoriteFood?: true
    hobby?: true
    lifeHistory?: true
    messageForChildren?: true
    skill?: true
    workingTime?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
  }

  export type InstructorCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    classURL?: true
    icon?: true
    nickname?: true
    meetingId?: true
    passcode?: true
    createdAt?: true
    birthdate?: true
    favoriteFood?: true
    hobby?: true
    lifeHistory?: true
    messageForChildren?: true
    skill?: true
    workingTime?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
    _all?: true
  }

  export type InstructorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructor to aggregate.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instructors
    **/
    _count?: true | InstructorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorMaxAggregateInputType
  }

  export type GetInstructorAggregateType<T extends InstructorAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructor[P]>
      : GetScalarType<T[P], AggregateInstructor[P]>
  }




  export type InstructorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorWhereInput
    orderBy?: InstructorOrderByWithAggregationInput | InstructorOrderByWithAggregationInput[]
    by: InstructorScalarFieldEnum[] | InstructorScalarFieldEnum
    having?: InstructorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorCountAggregateInputType | true
    _avg?: InstructorAvgAggregateInputType
    _sum?: InstructorSumAggregateInputType
    _min?: InstructorMinAggregateInputType
    _max?: InstructorMaxAggregateInputType
  }

  export type InstructorGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt: Date
    birthdate: Date
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt: Date | null
    updatedAt: Date
    isNative: boolean
    _count: InstructorCountAggregateOutputType | null
    _avg: InstructorAvgAggregateOutputType | null
    _sum: InstructorSumAggregateOutputType | null
    _min: InstructorMinAggregateOutputType | null
    _max: InstructorMaxAggregateOutputType | null
  }

  type GetInstructorGroupByPayload<T extends InstructorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorGroupByOutputType[P]>
        }
      >
    >


  export type InstructorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    classURL?: boolean
    icon?: boolean
    nickname?: boolean
    meetingId?: boolean
    passcode?: boolean
    createdAt?: boolean
    birthdate?: boolean
    favoriteFood?: boolean
    hobby?: boolean
    lifeHistory?: boolean
    messageForChildren?: boolean
    skill?: boolean
    workingTime?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
    classes?: boolean | Instructor$classesArgs<ExtArgs>
    instructorAbsences?: boolean | Instructor$instructorAbsencesArgs<ExtArgs>
    instructorSchedules?: boolean | Instructor$instructorSchedulesArgs<ExtArgs>
    recurringClasses?: boolean | Instructor$recurringClassesArgs<ExtArgs>
    _count?: boolean | InstructorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    classURL?: boolean
    icon?: boolean
    nickname?: boolean
    meetingId?: boolean
    passcode?: boolean
    createdAt?: boolean
    birthdate?: boolean
    favoriteFood?: boolean
    hobby?: boolean
    lifeHistory?: boolean
    messageForChildren?: boolean
    skill?: boolean
    workingTime?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    classURL?: boolean
    icon?: boolean
    nickname?: boolean
    meetingId?: boolean
    passcode?: boolean
    createdAt?: boolean
    birthdate?: boolean
    favoriteFood?: boolean
    hobby?: boolean
    lifeHistory?: boolean
    messageForChildren?: boolean
    skill?: boolean
    workingTime?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }, ExtArgs["result"]["instructor"]>

  export type InstructorSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    classURL?: boolean
    icon?: boolean
    nickname?: boolean
    meetingId?: boolean
    passcode?: boolean
    createdAt?: boolean
    birthdate?: boolean
    favoriteFood?: boolean
    hobby?: boolean
    lifeHistory?: boolean
    messageForChildren?: boolean
    skill?: boolean
    workingTime?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }

  export type InstructorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "classURL" | "icon" | "nickname" | "meetingId" | "passcode" | "createdAt" | "birthdate" | "favoriteFood" | "hobby" | "lifeHistory" | "messageForChildren" | "skill" | "workingTime" | "terminationAt" | "updatedAt" | "isNative", ExtArgs["result"]["instructor"]>
  export type InstructorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Instructor$classesArgs<ExtArgs>
    instructorAbsences?: boolean | Instructor$instructorAbsencesArgs<ExtArgs>
    instructorSchedules?: boolean | Instructor$instructorSchedulesArgs<ExtArgs>
    recurringClasses?: boolean | Instructor$recurringClassesArgs<ExtArgs>
    _count?: boolean | InstructorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstructorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InstructorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InstructorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instructor"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      instructorAbsences: Prisma.$InstructorAbsencePayload<ExtArgs>[]
      instructorSchedules: Prisma.$InstructorSchedulePayload<ExtArgs>[]
      recurringClasses: Prisma.$RecurringClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      classURL: string
      icon: string
      nickname: string
      meetingId: string
      passcode: string
      createdAt: Date
      birthdate: Date
      favoriteFood: string
      hobby: string
      lifeHistory: string
      messageForChildren: string
      skill: string
      workingTime: string
      terminationAt: Date | null
      updatedAt: Date
      isNative: boolean
    }, ExtArgs["result"]["instructor"]>
    composites: {}
  }

  type InstructorGetPayload<S extends boolean | null | undefined | InstructorDefaultArgs> = $Result.GetResult<Prisma.$InstructorPayload, S>

  type InstructorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstructorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstructorCountAggregateInputType | true
    }

  export interface InstructorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instructor'], meta: { name: 'Instructor' } }
    /**
     * Find zero or one Instructor that matches the filter.
     * @param {InstructorFindUniqueArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorFindUniqueArgs>(args: SelectSubset<T, InstructorFindUniqueArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instructor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstructorFindUniqueOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instructor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorFindFirstArgs>(args?: SelectSubset<T, InstructorFindFirstArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instructor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindFirstOrThrowArgs} args - Arguments to find a Instructor
     * @example
     * // Get one Instructor
     * const instructor = await prisma.instructor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instructors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructors
     * const instructors = await prisma.instructor.findMany()
     * 
     * // Get first 10 Instructors
     * const instructors = await prisma.instructor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorWithIdOnly = await prisma.instructor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstructorFindManyArgs>(args?: SelectSubset<T, InstructorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instructor.
     * @param {InstructorCreateArgs} args - Arguments to create a Instructor.
     * @example
     * // Create one Instructor
     * const Instructor = await prisma.instructor.create({
     *   data: {
     *     // ... data to create a Instructor
     *   }
     * })
     * 
     */
    create<T extends InstructorCreateArgs>(args: SelectSubset<T, InstructorCreateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instructors.
     * @param {InstructorCreateManyArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorCreateManyArgs>(args?: SelectSubset<T, InstructorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instructors and returns the data saved in the database.
     * @param {InstructorCreateManyAndReturnArgs} args - Arguments to create many Instructors.
     * @example
     * // Create many Instructors
     * const instructor = await prisma.instructor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instructors and only return the `id`
     * const instructorWithIdOnly = await prisma.instructor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instructor.
     * @param {InstructorDeleteArgs} args - Arguments to delete one Instructor.
     * @example
     * // Delete one Instructor
     * const Instructor = await prisma.instructor.delete({
     *   where: {
     *     // ... filter to delete one Instructor
     *   }
     * })
     * 
     */
    delete<T extends InstructorDeleteArgs>(args: SelectSubset<T, InstructorDeleteArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instructor.
     * @param {InstructorUpdateArgs} args - Arguments to update one Instructor.
     * @example
     * // Update one Instructor
     * const instructor = await prisma.instructor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorUpdateArgs>(args: SelectSubset<T, InstructorUpdateArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instructors.
     * @param {InstructorDeleteManyArgs} args - Arguments to filter Instructors to delete.
     * @example
     * // Delete a few Instructors
     * const { count } = await prisma.instructor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorDeleteManyArgs>(args?: SelectSubset<T, InstructorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorUpdateManyArgs>(args: SelectSubset<T, InstructorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructors and returns the data updated in the database.
     * @param {InstructorUpdateManyAndReturnArgs} args - Arguments to update many Instructors.
     * @example
     * // Update many Instructors
     * const instructor = await prisma.instructor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instructors and only return the `id`
     * const instructorWithIdOnly = await prisma.instructor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstructorUpdateManyAndReturnArgs>(args: SelectSubset<T, InstructorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instructor.
     * @param {InstructorUpsertArgs} args - Arguments to update or create a Instructor.
     * @example
     * // Update or create a Instructor
     * const instructor = await prisma.instructor.upsert({
     *   create: {
     *     // ... data to create a Instructor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instructor we want to update
     *   }
     * })
     */
    upsert<T extends InstructorUpsertArgs>(args: SelectSubset<T, InstructorUpsertArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instructors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorCountArgs} args - Arguments to filter Instructors to count.
     * @example
     * // Count the number of Instructors
     * const count = await prisma.instructor.count({
     *   where: {
     *     // ... the filter for the Instructors we want to count
     *   }
     * })
    **/
    count<T extends InstructorCountArgs>(
      args?: Subset<T, InstructorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAggregateArgs>(args: Subset<T, InstructorAggregateArgs>): Prisma.PrismaPromise<GetInstructorAggregateType<T>>

    /**
     * Group by Instructor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorGroupByArgs['orderBy'] }
        : { orderBy?: InstructorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instructor model
   */
  readonly fields: InstructorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instructor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Instructor$classesArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructorAbsences<T extends Instructor$instructorAbsencesArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$instructorAbsencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructorSchedules<T extends Instructor$instructorSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$instructorSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringClasses<T extends Instructor$recurringClassesArgs<ExtArgs> = {}>(args?: Subset<T, Instructor$recurringClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instructor model
   */
  interface InstructorFieldRefs {
    readonly id: FieldRef<"Instructor", 'Int'>
    readonly name: FieldRef<"Instructor", 'String'>
    readonly email: FieldRef<"Instructor", 'String'>
    readonly password: FieldRef<"Instructor", 'String'>
    readonly classURL: FieldRef<"Instructor", 'String'>
    readonly icon: FieldRef<"Instructor", 'String'>
    readonly nickname: FieldRef<"Instructor", 'String'>
    readonly meetingId: FieldRef<"Instructor", 'String'>
    readonly passcode: FieldRef<"Instructor", 'String'>
    readonly createdAt: FieldRef<"Instructor", 'DateTime'>
    readonly birthdate: FieldRef<"Instructor", 'DateTime'>
    readonly favoriteFood: FieldRef<"Instructor", 'String'>
    readonly hobby: FieldRef<"Instructor", 'String'>
    readonly lifeHistory: FieldRef<"Instructor", 'String'>
    readonly messageForChildren: FieldRef<"Instructor", 'String'>
    readonly skill: FieldRef<"Instructor", 'String'>
    readonly workingTime: FieldRef<"Instructor", 'String'>
    readonly terminationAt: FieldRef<"Instructor", 'DateTime'>
    readonly updatedAt: FieldRef<"Instructor", 'DateTime'>
    readonly isNative: FieldRef<"Instructor", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Instructor findUnique
   */
  export type InstructorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findUniqueOrThrow
   */
  export type InstructorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor findFirst
   */
  export type InstructorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findFirstOrThrow
   */
  export type InstructorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructor to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructors.
     */
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor findMany
   */
  export type InstructorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter, which Instructors to fetch.
     */
    where?: InstructorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructors to fetch.
     */
    orderBy?: InstructorOrderByWithRelationInput | InstructorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instructors.
     */
    cursor?: InstructorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructors.
     */
    skip?: number
    distinct?: InstructorScalarFieldEnum | InstructorScalarFieldEnum[]
  }

  /**
   * Instructor create
   */
  export type InstructorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to create a Instructor.
     */
    data: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
  }

  /**
   * Instructor createMany
   */
  export type InstructorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instructor createManyAndReturn
   */
  export type InstructorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * The data used to create many Instructors.
     */
    data: InstructorCreateManyInput | InstructorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instructor update
   */
  export type InstructorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The data needed to update a Instructor.
     */
    data: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
    /**
     * Choose, which Instructor to update.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor updateMany
   */
  export type InstructorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instructors.
     */
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyInput>
    /**
     * Filter which Instructors to update
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to update.
     */
    limit?: number
  }

  /**
   * Instructor updateManyAndReturn
   */
  export type InstructorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * The data used to update Instructors.
     */
    data: XOR<InstructorUpdateManyMutationInput, InstructorUncheckedUpdateManyInput>
    /**
     * Filter which Instructors to update
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to update.
     */
    limit?: number
  }

  /**
   * Instructor upsert
   */
  export type InstructorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * The filter to search for the Instructor to update in case it exists.
     */
    where: InstructorWhereUniqueInput
    /**
     * In case the Instructor found by the `where` argument doesn't exist, create a new Instructor with this data.
     */
    create: XOR<InstructorCreateInput, InstructorUncheckedCreateInput>
    /**
     * In case the Instructor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorUpdateInput, InstructorUncheckedUpdateInput>
  }

  /**
   * Instructor delete
   */
  export type InstructorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    /**
     * Filter which Instructor to delete.
     */
    where: InstructorWhereUniqueInput
  }

  /**
   * Instructor deleteMany
   */
  export type InstructorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructors to delete
     */
    where?: InstructorWhereInput
    /**
     * Limit how many Instructors to delete.
     */
    limit?: number
  }

  /**
   * Instructor.classes
   */
  export type Instructor$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Instructor.instructorAbsences
   */
  export type Instructor$instructorAbsencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    where?: InstructorAbsenceWhereInput
    orderBy?: InstructorAbsenceOrderByWithRelationInput | InstructorAbsenceOrderByWithRelationInput[]
    cursor?: InstructorAbsenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorAbsenceScalarFieldEnum | InstructorAbsenceScalarFieldEnum[]
  }

  /**
   * Instructor.instructorSchedules
   */
  export type Instructor$instructorSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    where?: InstructorScheduleWhereInput
    orderBy?: InstructorScheduleOrderByWithRelationInput | InstructorScheduleOrderByWithRelationInput[]
    cursor?: InstructorScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorScheduleScalarFieldEnum | InstructorScheduleScalarFieldEnum[]
  }

  /**
   * Instructor.recurringClasses
   */
  export type Instructor$recurringClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    where?: RecurringClassWhereInput
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    cursor?: RecurringClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringClassScalarFieldEnum | RecurringClassScalarFieldEnum[]
  }

  /**
   * Instructor without action
   */
  export type InstructorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    prefecture: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    hasSeenWelcome: boolean | null
    terminationAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    prefecture: string | null
    emailVerified: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    hasSeenWelcome: boolean | null
    terminationAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    prefecture: number
    emailVerified: number
    createdAt: number
    updatedAt: number
    hasSeenWelcome: number
    terminationAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    prefecture?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    hasSeenWelcome?: true
    terminationAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    prefecture?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    hasSeenWelcome?: true
    terminationAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    prefecture?: true
    emailVerified?: true
    createdAt?: true
    updatedAt?: true
    hasSeenWelcome?: true
    terminationAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified: Date | null
    createdAt: Date
    updatedAt: Date
    hasSeenWelcome: boolean
    terminationAt: Date | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    prefecture?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasSeenWelcome?: boolean
    terminationAt?: boolean
    children?: boolean | Customer$childrenArgs<ExtArgs>
    classes?: boolean | Customer$classesArgs<ExtArgs>
    subscription?: boolean | Customer$subscriptionArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    prefecture?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasSeenWelcome?: boolean
    terminationAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    prefecture?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasSeenWelcome?: boolean
    terminationAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    prefecture?: boolean
    emailVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hasSeenWelcome?: boolean
    terminationAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "prefecture" | "emailVerified" | "createdAt" | "updatedAt" | "hasSeenWelcome" | "terminationAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | Customer$childrenArgs<ExtArgs>
    classes?: boolean | Customer$classesArgs<ExtArgs>
    subscription?: boolean | Customer$subscriptionArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      children: Prisma.$ChildPayload<ExtArgs>[]
      classes: Prisma.$ClassPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      prefecture: string
      emailVerified: Date | null
      createdAt: Date
      updatedAt: Date
      hasSeenWelcome: boolean
      terminationAt: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    children<T extends Customer$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Customer$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends Customer$classesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscription<T extends Customer$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Customer$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly prefecture: FieldRef<"Customer", 'String'>
    readonly emailVerified: FieldRef<"Customer", 'DateTime'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly hasSeenWelcome: FieldRef<"Customer", 'Boolean'>
    readonly terminationAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.children
   */
  export type Customer$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    cursor?: ChildWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Customer.classes
   */
  export type Customer$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Customer.subscription
   */
  export type Customer$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    id: number | null
    instructorId: number | null
    customerId: number | null
    recurringClassId: number | null
    subscriptionId: number | null
  }

  export type ClassSumAggregateOutputType = {
    id: number | null
    instructorId: number | null
    customerId: number | null
    recurringClassId: number | null
    subscriptionId: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: number | null
    instructorId: number | null
    customerId: number | null
    recurringClassId: number | null
    dateTime: Date | null
    status: $Enums.Status | null
    subscriptionId: number | null
    rebookableUntil: Date | null
    classCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isFreeTrial: boolean | null
  }

  export type ClassMaxAggregateOutputType = {
    id: number | null
    instructorId: number | null
    customerId: number | null
    recurringClassId: number | null
    dateTime: Date | null
    status: $Enums.Status | null
    subscriptionId: number | null
    rebookableUntil: Date | null
    classCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isFreeTrial: boolean | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    instructorId: number
    customerId: number
    recurringClassId: number
    dateTime: number
    status: number
    subscriptionId: number
    rebookableUntil: number
    classCode: number
    createdAt: number
    updatedAt: number
    isFreeTrial: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    id?: true
    instructorId?: true
    customerId?: true
    recurringClassId?: true
    subscriptionId?: true
  }

  export type ClassSumAggregateInputType = {
    id?: true
    instructorId?: true
    customerId?: true
    recurringClassId?: true
    subscriptionId?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    instructorId?: true
    customerId?: true
    recurringClassId?: true
    dateTime?: true
    status?: true
    subscriptionId?: true
    rebookableUntil?: true
    classCode?: true
    createdAt?: true
    updatedAt?: true
    isFreeTrial?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    instructorId?: true
    customerId?: true
    recurringClassId?: true
    dateTime?: true
    status?: true
    subscriptionId?: true
    rebookableUntil?: true
    classCode?: true
    createdAt?: true
    updatedAt?: true
    isFreeTrial?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    instructorId?: true
    customerId?: true
    recurringClassId?: true
    dateTime?: true
    status?: true
    subscriptionId?: true
    rebookableUntil?: true
    classCode?: true
    createdAt?: true
    updatedAt?: true
    isFreeTrial?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: number
    instructorId: number | null
    customerId: number
    recurringClassId: number | null
    dateTime: Date | null
    status: $Enums.Status
    subscriptionId: number | null
    rebookableUntil: Date | null
    classCode: string
    createdAt: Date
    updatedAt: Date
    isFreeTrial: boolean
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    customerId?: boolean
    recurringClassId?: boolean
    dateTime?: boolean
    status?: boolean
    subscriptionId?: boolean
    rebookableUntil?: boolean
    classCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFreeTrial?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
    classAttendance?: boolean | Class$classAttendanceArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    customerId?: boolean
    recurringClassId?: boolean
    dateTime?: boolean
    status?: boolean
    subscriptionId?: boolean
    rebookableUntil?: boolean
    classCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFreeTrial?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    customerId?: boolean
    recurringClassId?: boolean
    dateTime?: boolean
    status?: boolean
    subscriptionId?: boolean
    rebookableUntil?: boolean
    classCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFreeTrial?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    instructorId?: boolean
    customerId?: boolean
    recurringClassId?: boolean
    dateTime?: boolean
    status?: boolean
    subscriptionId?: boolean
    rebookableUntil?: boolean
    classCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isFreeTrial?: boolean
  }

  export type ClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instructorId" | "customerId" | "recurringClassId" | "dateTime" | "status" | "subscriptionId" | "rebookableUntil" | "classCode" | "createdAt" | "updatedAt" | "isFreeTrial", ExtArgs["result"]["class"]>
  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
    classAttendance?: boolean | Class$classAttendanceArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
  }
  export type ClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    instructor?: boolean | Class$instructorArgs<ExtArgs>
    recurringClass?: boolean | Class$recurringClassArgs<ExtArgs>
    subscription?: boolean | Class$subscriptionArgs<ExtArgs>
  }

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      instructor: Prisma.$InstructorPayload<ExtArgs> | null
      recurringClass: Prisma.$RecurringClassPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      classAttendance: Prisma.$ClassAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instructorId: number | null
      customerId: number
      recurringClassId: number | null
      dateTime: Date | null
      status: $Enums.Status
      subscriptionId: number | null
      rebookableUntil: Date | null
      classCode: string
      createdAt: Date
      updatedAt: Date
      isFreeTrial: boolean
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes and returns the data updated in the database.
     * @param {ClassUpdateManyAndReturnArgs} args - Arguments to update many Classes.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    instructor<T extends Class$instructorArgs<ExtArgs> = {}>(args?: Subset<T, Class$instructorArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recurringClass<T extends Class$recurringClassArgs<ExtArgs> = {}>(args?: Subset<T, Class$recurringClassArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscription<T extends Class$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Class$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    classAttendance<T extends Class$classAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Class$classAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'Int'>
    readonly instructorId: FieldRef<"Class", 'Int'>
    readonly customerId: FieldRef<"Class", 'Int'>
    readonly recurringClassId: FieldRef<"Class", 'Int'>
    readonly dateTime: FieldRef<"Class", 'DateTime'>
    readonly status: FieldRef<"Class", 'Status'>
    readonly subscriptionId: FieldRef<"Class", 'Int'>
    readonly rebookableUntil: FieldRef<"Class", 'DateTime'>
    readonly classCode: FieldRef<"Class", 'String'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
    readonly isFreeTrial: FieldRef<"Class", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
  }

  /**
   * Class updateManyAndReturn
   */
  export type ClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
    /**
     * Limit how many Classes to delete.
     */
    limit?: number
  }

  /**
   * Class.instructor
   */
  export type Class$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
  }

  /**
   * Class.recurringClass
   */
  export type Class$recurringClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    where?: RecurringClassWhereInput
  }

  /**
   * Class.subscription
   */
  export type Class$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * Class.classAttendance
   */
  export type Class$classAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    where?: ClassAttendanceWhereInput
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    cursor?: ClassAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassAttendanceScalarFieldEnum | ClassAttendanceScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassAttendance
   */

  export type AggregateClassAttendance = {
    _count: ClassAttendanceCountAggregateOutputType | null
    _avg: ClassAttendanceAvgAggregateOutputType | null
    _sum: ClassAttendanceSumAggregateOutputType | null
    _min: ClassAttendanceMinAggregateOutputType | null
    _max: ClassAttendanceMaxAggregateOutputType | null
  }

  export type ClassAttendanceAvgAggregateOutputType = {
    classId: number | null
    childrenId: number | null
  }

  export type ClassAttendanceSumAggregateOutputType = {
    classId: number | null
    childrenId: number | null
  }

  export type ClassAttendanceMinAggregateOutputType = {
    classId: number | null
    childrenId: number | null
  }

  export type ClassAttendanceMaxAggregateOutputType = {
    classId: number | null
    childrenId: number | null
  }

  export type ClassAttendanceCountAggregateOutputType = {
    classId: number
    childrenId: number
    _all: number
  }


  export type ClassAttendanceAvgAggregateInputType = {
    classId?: true
    childrenId?: true
  }

  export type ClassAttendanceSumAggregateInputType = {
    classId?: true
    childrenId?: true
  }

  export type ClassAttendanceMinAggregateInputType = {
    classId?: true
    childrenId?: true
  }

  export type ClassAttendanceMaxAggregateInputType = {
    classId?: true
    childrenId?: true
  }

  export type ClassAttendanceCountAggregateInputType = {
    classId?: true
    childrenId?: true
    _all?: true
  }

  export type ClassAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassAttendance to aggregate.
     */
    where?: ClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAttendances to fetch.
     */
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassAttendances
    **/
    _count?: true | ClassAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassAttendanceMaxAggregateInputType
  }

  export type GetClassAttendanceAggregateType<T extends ClassAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateClassAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassAttendance[P]>
      : GetScalarType<T[P], AggregateClassAttendance[P]>
  }




  export type ClassAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassAttendanceWhereInput
    orderBy?: ClassAttendanceOrderByWithAggregationInput | ClassAttendanceOrderByWithAggregationInput[]
    by: ClassAttendanceScalarFieldEnum[] | ClassAttendanceScalarFieldEnum
    having?: ClassAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassAttendanceCountAggregateInputType | true
    _avg?: ClassAttendanceAvgAggregateInputType
    _sum?: ClassAttendanceSumAggregateInputType
    _min?: ClassAttendanceMinAggregateInputType
    _max?: ClassAttendanceMaxAggregateInputType
  }

  export type ClassAttendanceGroupByOutputType = {
    classId: number
    childrenId: number
    _count: ClassAttendanceCountAggregateOutputType | null
    _avg: ClassAttendanceAvgAggregateOutputType | null
    _sum: ClassAttendanceSumAggregateOutputType | null
    _min: ClassAttendanceMinAggregateOutputType | null
    _max: ClassAttendanceMaxAggregateOutputType | null
  }

  type GetClassAttendanceGroupByPayload<T extends ClassAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], ClassAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type ClassAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classAttendance"]>

  export type ClassAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classAttendance"]>

  export type ClassAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classAttendance"]>

  export type ClassAttendanceSelectScalar = {
    classId?: boolean
    childrenId?: boolean
  }

  export type ClassAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"classId" | "childrenId", ExtArgs["result"]["classAttendance"]>
  export type ClassAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type ClassAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $ClassAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassAttendance"
    objects: {
      children: Prisma.$ChildPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      classId: number
      childrenId: number
    }, ExtArgs["result"]["classAttendance"]>
    composites: {}
  }

  type ClassAttendanceGetPayload<S extends boolean | null | undefined | ClassAttendanceDefaultArgs> = $Result.GetResult<Prisma.$ClassAttendancePayload, S>

  type ClassAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassAttendanceCountAggregateInputType | true
    }

  export interface ClassAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassAttendance'], meta: { name: 'ClassAttendance' } }
    /**
     * Find zero or one ClassAttendance that matches the filter.
     * @param {ClassAttendanceFindUniqueArgs} args - Arguments to find a ClassAttendance
     * @example
     * // Get one ClassAttendance
     * const classAttendance = await prisma.classAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassAttendanceFindUniqueArgs>(args: SelectSubset<T, ClassAttendanceFindUniqueArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassAttendanceFindUniqueOrThrowArgs} args - Arguments to find a ClassAttendance
     * @example
     * // Get one ClassAttendance
     * const classAttendance = await prisma.classAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceFindFirstArgs} args - Arguments to find a ClassAttendance
     * @example
     * // Get one ClassAttendance
     * const classAttendance = await prisma.classAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassAttendanceFindFirstArgs>(args?: SelectSubset<T, ClassAttendanceFindFirstArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceFindFirstOrThrowArgs} args - Arguments to find a ClassAttendance
     * @example
     * // Get one ClassAttendance
     * const classAttendance = await prisma.classAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassAttendances
     * const classAttendances = await prisma.classAttendance.findMany()
     * 
     * // Get first 10 ClassAttendances
     * const classAttendances = await prisma.classAttendance.findMany({ take: 10 })
     * 
     * // Only select the `classId`
     * const classAttendanceWithClassIdOnly = await prisma.classAttendance.findMany({ select: { classId: true } })
     * 
     */
    findMany<T extends ClassAttendanceFindManyArgs>(args?: SelectSubset<T, ClassAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassAttendance.
     * @param {ClassAttendanceCreateArgs} args - Arguments to create a ClassAttendance.
     * @example
     * // Create one ClassAttendance
     * const ClassAttendance = await prisma.classAttendance.create({
     *   data: {
     *     // ... data to create a ClassAttendance
     *   }
     * })
     * 
     */
    create<T extends ClassAttendanceCreateArgs>(args: SelectSubset<T, ClassAttendanceCreateArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassAttendances.
     * @param {ClassAttendanceCreateManyArgs} args - Arguments to create many ClassAttendances.
     * @example
     * // Create many ClassAttendances
     * const classAttendance = await prisma.classAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassAttendanceCreateManyArgs>(args?: SelectSubset<T, ClassAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassAttendances and returns the data saved in the database.
     * @param {ClassAttendanceCreateManyAndReturnArgs} args - Arguments to create many ClassAttendances.
     * @example
     * // Create many ClassAttendances
     * const classAttendance = await prisma.classAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassAttendances and only return the `classId`
     * const classAttendanceWithClassIdOnly = await prisma.classAttendance.createManyAndReturn({
     *   select: { classId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassAttendance.
     * @param {ClassAttendanceDeleteArgs} args - Arguments to delete one ClassAttendance.
     * @example
     * // Delete one ClassAttendance
     * const ClassAttendance = await prisma.classAttendance.delete({
     *   where: {
     *     // ... filter to delete one ClassAttendance
     *   }
     * })
     * 
     */
    delete<T extends ClassAttendanceDeleteArgs>(args: SelectSubset<T, ClassAttendanceDeleteArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassAttendance.
     * @param {ClassAttendanceUpdateArgs} args - Arguments to update one ClassAttendance.
     * @example
     * // Update one ClassAttendance
     * const classAttendance = await prisma.classAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassAttendanceUpdateArgs>(args: SelectSubset<T, ClassAttendanceUpdateArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassAttendances.
     * @param {ClassAttendanceDeleteManyArgs} args - Arguments to filter ClassAttendances to delete.
     * @example
     * // Delete a few ClassAttendances
     * const { count } = await prisma.classAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassAttendanceDeleteManyArgs>(args?: SelectSubset<T, ClassAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassAttendances
     * const classAttendance = await prisma.classAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassAttendanceUpdateManyArgs>(args: SelectSubset<T, ClassAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassAttendances and returns the data updated in the database.
     * @param {ClassAttendanceUpdateManyAndReturnArgs} args - Arguments to update many ClassAttendances.
     * @example
     * // Update many ClassAttendances
     * const classAttendance = await prisma.classAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassAttendances and only return the `classId`
     * const classAttendanceWithClassIdOnly = await prisma.classAttendance.updateManyAndReturn({
     *   select: { classId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassAttendance.
     * @param {ClassAttendanceUpsertArgs} args - Arguments to update or create a ClassAttendance.
     * @example
     * // Update or create a ClassAttendance
     * const classAttendance = await prisma.classAttendance.upsert({
     *   create: {
     *     // ... data to create a ClassAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassAttendance we want to update
     *   }
     * })
     */
    upsert<T extends ClassAttendanceUpsertArgs>(args: SelectSubset<T, ClassAttendanceUpsertArgs<ExtArgs>>): Prisma__ClassAttendanceClient<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceCountArgs} args - Arguments to filter ClassAttendances to count.
     * @example
     * // Count the number of ClassAttendances
     * const count = await prisma.classAttendance.count({
     *   where: {
     *     // ... the filter for the ClassAttendances we want to count
     *   }
     * })
    **/
    count<T extends ClassAttendanceCountArgs>(
      args?: Subset<T, ClassAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAttendanceAggregateArgs>(args: Subset<T, ClassAttendanceAggregateArgs>): Prisma.PrismaPromise<GetClassAttendanceAggregateType<T>>

    /**
     * Group by ClassAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: ClassAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassAttendance model
   */
  readonly fields: ClassAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    children<T extends ChildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChildDefaultArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassAttendance model
   */
  interface ClassAttendanceFieldRefs {
    readonly classId: FieldRef<"ClassAttendance", 'Int'>
    readonly childrenId: FieldRef<"ClassAttendance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ClassAttendance findUnique
   */
  export type ClassAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which ClassAttendance to fetch.
     */
    where: ClassAttendanceWhereUniqueInput
  }

  /**
   * ClassAttendance findUniqueOrThrow
   */
  export type ClassAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which ClassAttendance to fetch.
     */
    where: ClassAttendanceWhereUniqueInput
  }

  /**
   * ClassAttendance findFirst
   */
  export type ClassAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which ClassAttendance to fetch.
     */
    where?: ClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAttendances to fetch.
     */
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassAttendances.
     */
    cursor?: ClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassAttendances.
     */
    distinct?: ClassAttendanceScalarFieldEnum | ClassAttendanceScalarFieldEnum[]
  }

  /**
   * ClassAttendance findFirstOrThrow
   */
  export type ClassAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which ClassAttendance to fetch.
     */
    where?: ClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAttendances to fetch.
     */
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassAttendances.
     */
    cursor?: ClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassAttendances.
     */
    distinct?: ClassAttendanceScalarFieldEnum | ClassAttendanceScalarFieldEnum[]
  }

  /**
   * ClassAttendance findMany
   */
  export type ClassAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which ClassAttendances to fetch.
     */
    where?: ClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassAttendances to fetch.
     */
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassAttendances.
     */
    cursor?: ClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassAttendances.
     */
    skip?: number
    distinct?: ClassAttendanceScalarFieldEnum | ClassAttendanceScalarFieldEnum[]
  }

  /**
   * ClassAttendance create
   */
  export type ClassAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassAttendance.
     */
    data: XOR<ClassAttendanceCreateInput, ClassAttendanceUncheckedCreateInput>
  }

  /**
   * ClassAttendance createMany
   */
  export type ClassAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassAttendances.
     */
    data: ClassAttendanceCreateManyInput | ClassAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassAttendance createManyAndReturn
   */
  export type ClassAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many ClassAttendances.
     */
    data: ClassAttendanceCreateManyInput | ClassAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassAttendance update
   */
  export type ClassAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassAttendance.
     */
    data: XOR<ClassAttendanceUpdateInput, ClassAttendanceUncheckedUpdateInput>
    /**
     * Choose, which ClassAttendance to update.
     */
    where: ClassAttendanceWhereUniqueInput
  }

  /**
   * ClassAttendance updateMany
   */
  export type ClassAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassAttendances.
     */
    data: XOR<ClassAttendanceUpdateManyMutationInput, ClassAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which ClassAttendances to update
     */
    where?: ClassAttendanceWhereInput
    /**
     * Limit how many ClassAttendances to update.
     */
    limit?: number
  }

  /**
   * ClassAttendance updateManyAndReturn
   */
  export type ClassAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update ClassAttendances.
     */
    data: XOR<ClassAttendanceUpdateManyMutationInput, ClassAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which ClassAttendances to update
     */
    where?: ClassAttendanceWhereInput
    /**
     * Limit how many ClassAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassAttendance upsert
   */
  export type ClassAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassAttendance to update in case it exists.
     */
    where: ClassAttendanceWhereUniqueInput
    /**
     * In case the ClassAttendance found by the `where` argument doesn't exist, create a new ClassAttendance with this data.
     */
    create: XOR<ClassAttendanceCreateInput, ClassAttendanceUncheckedCreateInput>
    /**
     * In case the ClassAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassAttendanceUpdateInput, ClassAttendanceUncheckedUpdateInput>
  }

  /**
   * ClassAttendance delete
   */
  export type ClassAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter which ClassAttendance to delete.
     */
    where: ClassAttendanceWhereUniqueInput
  }

  /**
   * ClassAttendance deleteMany
   */
  export type ClassAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassAttendances to delete
     */
    where?: ClassAttendanceWhereInput
    /**
     * Limit how many ClassAttendances to delete.
     */
    limit?: number
  }

  /**
   * ClassAttendance without action
   */
  export type ClassAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    id: number | null
    weeklyClassTimes: number | null
  }

  export type PlanSumAggregateOutputType = {
    id: number | null
    weeklyClassTimes: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    weeklyClassTimes: number | null
    createdAt: Date | null
    terminationAt: Date | null
    updatedAt: Date | null
    isNative: boolean | null
  }

  export type PlanMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    weeklyClassTimes: number | null
    createdAt: Date | null
    terminationAt: Date | null
    updatedAt: Date | null
    isNative: boolean | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    weeklyClassTimes: number
    createdAt: number
    terminationAt: number
    updatedAt: number
    isNative: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    id?: true
    weeklyClassTimes?: true
  }

  export type PlanSumAggregateInputType = {
    id?: true
    weeklyClassTimes?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weeklyClassTimes?: true
    createdAt?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weeklyClassTimes?: true
    createdAt?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    weeklyClassTimes?: true
    createdAt?: true
    terminationAt?: true
    updatedAt?: true
    isNative?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: number
    name: string
    description: string
    weeklyClassTimes: number
    createdAt: Date
    terminationAt: Date | null
    updatedAt: Date
    isNative: boolean
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    weeklyClassTimes?: boolean
    createdAt?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
    subscription?: boolean | Plan$subscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    weeklyClassTimes?: boolean
    createdAt?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    weeklyClassTimes?: boolean
    createdAt?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    weeklyClassTimes?: boolean
    createdAt?: boolean
    terminationAt?: boolean
    updatedAt?: boolean
    isNative?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "weeklyClassTimes" | "createdAt" | "terminationAt" | "updatedAt" | "isNative", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | Plan$subscriptionArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      weeklyClassTimes: number
      createdAt: Date
      terminationAt: Date | null
      updatedAt: Date
      isNative: boolean
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends Plan$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'Int'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly weeklyClassTimes: FieldRef<"Plan", 'Int'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly terminationAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
    readonly isNative: FieldRef<"Plan", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.subscription
   */
  export type Plan$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    id: number | null
    planId: number | null
    customerId: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    id: number | null
    planId: number | null
    customerId: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: number | null
    planId: number | null
    customerId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: number | null
    planId: number | null
    customerId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    planId: number
    customerId: number
    startAt: number
    endAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    id?: true
    planId?: true
    customerId?: true
  }

  export type SubscriptionSumAggregateInputType = {
    id?: true
    planId?: true
    customerId?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    planId?: true
    customerId?: true
    startAt?: true
    endAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    planId?: true
    customerId?: true
    startAt?: true
    endAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    planId?: true
    customerId?: true
    startAt?: true
    endAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: number
    planId: number
    customerId: number
    startAt: Date
    endAt: Date | null
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    customerId?: boolean
    startAt?: boolean
    endAt?: boolean
    class?: boolean | Subscription$classArgs<ExtArgs>
    recurringClass?: boolean | Subscription$recurringClassArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    customerId?: boolean
    startAt?: boolean
    endAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    customerId?: boolean
    startAt?: boolean
    endAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    planId?: boolean
    customerId?: boolean
    startAt?: boolean
    endAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "customerId" | "startAt" | "endAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | Subscription$classArgs<ExtArgs>
    recurringClass?: boolean | Subscription$recurringClassArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>[]
      recurringClass: Prisma.$RecurringClassPayload<ExtArgs>[]
      customer: Prisma.$CustomerPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      planId: number
      customerId: number
      startAt: Date
      endAt: Date | null
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends Subscription$classArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$classArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringClass<T extends Subscription$recurringClassArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$recurringClassArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'Int'>
    readonly planId: FieldRef<"Subscription", 'Int'>
    readonly customerId: FieldRef<"Subscription", 'Int'>
    readonly startAt: FieldRef<"Subscription", 'DateTime'>
    readonly endAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.class
   */
  export type Subscription$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Subscription.recurringClass
   */
  export type Subscription$recurringClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    where?: RecurringClassWhereInput
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    cursor?: RecurringClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringClassScalarFieldEnum | RecurringClassScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model RecurringClass
   */

  export type AggregateRecurringClass = {
    _count: RecurringClassCountAggregateOutputType | null
    _avg: RecurringClassAvgAggregateOutputType | null
    _sum: RecurringClassSumAggregateOutputType | null
    _min: RecurringClassMinAggregateOutputType | null
    _max: RecurringClassMaxAggregateOutputType | null
  }

  export type RecurringClassAvgAggregateOutputType = {
    id: number | null
    instructorId: number | null
    subscriptionId: number | null
  }

  export type RecurringClassSumAggregateOutputType = {
    id: number | null
    instructorId: number | null
    subscriptionId: number | null
  }

  export type RecurringClassMinAggregateOutputType = {
    id: number | null
    instructorId: number | null
    subscriptionId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type RecurringClassMaxAggregateOutputType = {
    id: number | null
    instructorId: number | null
    subscriptionId: number | null
    startAt: Date | null
    endAt: Date | null
  }

  export type RecurringClassCountAggregateOutputType = {
    id: number
    instructorId: number
    subscriptionId: number
    startAt: number
    endAt: number
    _all: number
  }


  export type RecurringClassAvgAggregateInputType = {
    id?: true
    instructorId?: true
    subscriptionId?: true
  }

  export type RecurringClassSumAggregateInputType = {
    id?: true
    instructorId?: true
    subscriptionId?: true
  }

  export type RecurringClassMinAggregateInputType = {
    id?: true
    instructorId?: true
    subscriptionId?: true
    startAt?: true
    endAt?: true
  }

  export type RecurringClassMaxAggregateInputType = {
    id?: true
    instructorId?: true
    subscriptionId?: true
    startAt?: true
    endAt?: true
  }

  export type RecurringClassCountAggregateInputType = {
    id?: true
    instructorId?: true
    subscriptionId?: true
    startAt?: true
    endAt?: true
    _all?: true
  }

  export type RecurringClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringClass to aggregate.
     */
    where?: RecurringClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClasses to fetch.
     */
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringClasses
    **/
    _count?: true | RecurringClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringClassMaxAggregateInputType
  }

  export type GetRecurringClassAggregateType<T extends RecurringClassAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringClass[P]>
      : GetScalarType<T[P], AggregateRecurringClass[P]>
  }




  export type RecurringClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassWhereInput
    orderBy?: RecurringClassOrderByWithAggregationInput | RecurringClassOrderByWithAggregationInput[]
    by: RecurringClassScalarFieldEnum[] | RecurringClassScalarFieldEnum
    having?: RecurringClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringClassCountAggregateInputType | true
    _avg?: RecurringClassAvgAggregateInputType
    _sum?: RecurringClassSumAggregateInputType
    _min?: RecurringClassMinAggregateInputType
    _max?: RecurringClassMaxAggregateInputType
  }

  export type RecurringClassGroupByOutputType = {
    id: number
    instructorId: number | null
    subscriptionId: number | null
    startAt: Date | null
    endAt: Date | null
    _count: RecurringClassCountAggregateOutputType | null
    _avg: RecurringClassAvgAggregateOutputType | null
    _sum: RecurringClassSumAggregateOutputType | null
    _min: RecurringClassMinAggregateOutputType | null
    _max: RecurringClassMaxAggregateOutputType | null
  }

  type GetRecurringClassGroupByPayload<T extends RecurringClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringClassGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringClassGroupByOutputType[P]>
        }
      >
    >


  export type RecurringClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    subscriptionId?: boolean
    startAt?: boolean
    endAt?: boolean
    classes?: boolean | RecurringClass$classesArgs<ExtArgs>
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
    recurringClassAttendance?: boolean | RecurringClass$recurringClassAttendanceArgs<ExtArgs>
    _count?: boolean | RecurringClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClass"]>

  export type RecurringClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    subscriptionId?: boolean
    startAt?: boolean
    endAt?: boolean
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClass"]>

  export type RecurringClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    subscriptionId?: boolean
    startAt?: boolean
    endAt?: boolean
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClass"]>

  export type RecurringClassSelectScalar = {
    id?: boolean
    instructorId?: boolean
    subscriptionId?: boolean
    startAt?: boolean
    endAt?: boolean
  }

  export type RecurringClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instructorId" | "subscriptionId" | "startAt" | "endAt", ExtArgs["result"]["recurringClass"]>
  export type RecurringClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | RecurringClass$classesArgs<ExtArgs>
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
    recurringClassAttendance?: boolean | RecurringClass$recurringClassAttendanceArgs<ExtArgs>
    _count?: boolean | RecurringClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RecurringClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
  }
  export type RecurringClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | RecurringClass$instructorArgs<ExtArgs>
    subscription?: boolean | RecurringClass$subscriptionArgs<ExtArgs>
  }

  export type $RecurringClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringClass"
    objects: {
      classes: Prisma.$ClassPayload<ExtArgs>[]
      instructor: Prisma.$InstructorPayload<ExtArgs> | null
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      recurringClassAttendance: Prisma.$RecurringClassAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instructorId: number | null
      subscriptionId: number | null
      startAt: Date | null
      endAt: Date | null
    }, ExtArgs["result"]["recurringClass"]>
    composites: {}
  }

  type RecurringClassGetPayload<S extends boolean | null | undefined | RecurringClassDefaultArgs> = $Result.GetResult<Prisma.$RecurringClassPayload, S>

  type RecurringClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringClassCountAggregateInputType | true
    }

  export interface RecurringClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringClass'], meta: { name: 'RecurringClass' } }
    /**
     * Find zero or one RecurringClass that matches the filter.
     * @param {RecurringClassFindUniqueArgs} args - Arguments to find a RecurringClass
     * @example
     * // Get one RecurringClass
     * const recurringClass = await prisma.recurringClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringClassFindUniqueArgs>(args: SelectSubset<T, RecurringClassFindUniqueArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringClassFindUniqueOrThrowArgs} args - Arguments to find a RecurringClass
     * @example
     * // Get one RecurringClass
     * const recurringClass = await prisma.recurringClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringClassFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassFindFirstArgs} args - Arguments to find a RecurringClass
     * @example
     * // Get one RecurringClass
     * const recurringClass = await prisma.recurringClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringClassFindFirstArgs>(args?: SelectSubset<T, RecurringClassFindFirstArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassFindFirstOrThrowArgs} args - Arguments to find a RecurringClass
     * @example
     * // Get one RecurringClass
     * const recurringClass = await prisma.recurringClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringClassFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringClasses
     * const recurringClasses = await prisma.recurringClass.findMany()
     * 
     * // Get first 10 RecurringClasses
     * const recurringClasses = await prisma.recurringClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recurringClassWithIdOnly = await prisma.recurringClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecurringClassFindManyArgs>(args?: SelectSubset<T, RecurringClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringClass.
     * @param {RecurringClassCreateArgs} args - Arguments to create a RecurringClass.
     * @example
     * // Create one RecurringClass
     * const RecurringClass = await prisma.recurringClass.create({
     *   data: {
     *     // ... data to create a RecurringClass
     *   }
     * })
     * 
     */
    create<T extends RecurringClassCreateArgs>(args: SelectSubset<T, RecurringClassCreateArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringClasses.
     * @param {RecurringClassCreateManyArgs} args - Arguments to create many RecurringClasses.
     * @example
     * // Create many RecurringClasses
     * const recurringClass = await prisma.recurringClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringClassCreateManyArgs>(args?: SelectSubset<T, RecurringClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringClasses and returns the data saved in the database.
     * @param {RecurringClassCreateManyAndReturnArgs} args - Arguments to create many RecurringClasses.
     * @example
     * // Create many RecurringClasses
     * const recurringClass = await prisma.recurringClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringClasses and only return the `id`
     * const recurringClassWithIdOnly = await prisma.recurringClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringClassCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringClass.
     * @param {RecurringClassDeleteArgs} args - Arguments to delete one RecurringClass.
     * @example
     * // Delete one RecurringClass
     * const RecurringClass = await prisma.recurringClass.delete({
     *   where: {
     *     // ... filter to delete one RecurringClass
     *   }
     * })
     * 
     */
    delete<T extends RecurringClassDeleteArgs>(args: SelectSubset<T, RecurringClassDeleteArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringClass.
     * @param {RecurringClassUpdateArgs} args - Arguments to update one RecurringClass.
     * @example
     * // Update one RecurringClass
     * const recurringClass = await prisma.recurringClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringClassUpdateArgs>(args: SelectSubset<T, RecurringClassUpdateArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringClasses.
     * @param {RecurringClassDeleteManyArgs} args - Arguments to filter RecurringClasses to delete.
     * @example
     * // Delete a few RecurringClasses
     * const { count } = await prisma.recurringClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringClassDeleteManyArgs>(args?: SelectSubset<T, RecurringClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringClasses
     * const recurringClass = await prisma.recurringClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringClassUpdateManyArgs>(args: SelectSubset<T, RecurringClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringClasses and returns the data updated in the database.
     * @param {RecurringClassUpdateManyAndReturnArgs} args - Arguments to update many RecurringClasses.
     * @example
     * // Update many RecurringClasses
     * const recurringClass = await prisma.recurringClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringClasses and only return the `id`
     * const recurringClassWithIdOnly = await prisma.recurringClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringClassUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringClass.
     * @param {RecurringClassUpsertArgs} args - Arguments to update or create a RecurringClass.
     * @example
     * // Update or create a RecurringClass
     * const recurringClass = await prisma.recurringClass.upsert({
     *   create: {
     *     // ... data to create a RecurringClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringClass we want to update
     *   }
     * })
     */
    upsert<T extends RecurringClassUpsertArgs>(args: SelectSubset<T, RecurringClassUpsertArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassCountArgs} args - Arguments to filter RecurringClasses to count.
     * @example
     * // Count the number of RecurringClasses
     * const count = await prisma.recurringClass.count({
     *   where: {
     *     // ... the filter for the RecurringClasses we want to count
     *   }
     * })
    **/
    count<T extends RecurringClassCountArgs>(
      args?: Subset<T, RecurringClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringClassAggregateArgs>(args: Subset<T, RecurringClassAggregateArgs>): Prisma.PrismaPromise<GetRecurringClassAggregateType<T>>

    /**
     * Group by RecurringClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringClassGroupByArgs['orderBy'] }
        : { orderBy?: RecurringClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringClass model
   */
  readonly fields: RecurringClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends RecurringClass$classesArgs<ExtArgs> = {}>(args?: Subset<T, RecurringClass$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instructor<T extends RecurringClass$instructorArgs<ExtArgs> = {}>(args?: Subset<T, RecurringClass$instructorArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subscription<T extends RecurringClass$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, RecurringClass$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recurringClassAttendance<T extends RecurringClass$recurringClassAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, RecurringClass$recurringClassAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringClass model
   */
  interface RecurringClassFieldRefs {
    readonly id: FieldRef<"RecurringClass", 'Int'>
    readonly instructorId: FieldRef<"RecurringClass", 'Int'>
    readonly subscriptionId: FieldRef<"RecurringClass", 'Int'>
    readonly startAt: FieldRef<"RecurringClass", 'DateTime'>
    readonly endAt: FieldRef<"RecurringClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RecurringClass findUnique
   */
  export type RecurringClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClass to fetch.
     */
    where: RecurringClassWhereUniqueInput
  }

  /**
   * RecurringClass findUniqueOrThrow
   */
  export type RecurringClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClass to fetch.
     */
    where: RecurringClassWhereUniqueInput
  }

  /**
   * RecurringClass findFirst
   */
  export type RecurringClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClass to fetch.
     */
    where?: RecurringClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClasses to fetch.
     */
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringClasses.
     */
    cursor?: RecurringClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringClasses.
     */
    distinct?: RecurringClassScalarFieldEnum | RecurringClassScalarFieldEnum[]
  }

  /**
   * RecurringClass findFirstOrThrow
   */
  export type RecurringClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClass to fetch.
     */
    where?: RecurringClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClasses to fetch.
     */
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringClasses.
     */
    cursor?: RecurringClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringClasses.
     */
    distinct?: RecurringClassScalarFieldEnum | RecurringClassScalarFieldEnum[]
  }

  /**
   * RecurringClass findMany
   */
  export type RecurringClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClasses to fetch.
     */
    where?: RecurringClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClasses to fetch.
     */
    orderBy?: RecurringClassOrderByWithRelationInput | RecurringClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringClasses.
     */
    cursor?: RecurringClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClasses.
     */
    skip?: number
    distinct?: RecurringClassScalarFieldEnum | RecurringClassScalarFieldEnum[]
  }

  /**
   * RecurringClass create
   */
  export type RecurringClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringClass.
     */
    data?: XOR<RecurringClassCreateInput, RecurringClassUncheckedCreateInput>
  }

  /**
   * RecurringClass createMany
   */
  export type RecurringClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringClasses.
     */
    data: RecurringClassCreateManyInput | RecurringClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringClass createManyAndReturn
   */
  export type RecurringClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringClasses.
     */
    data: RecurringClassCreateManyInput | RecurringClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringClass update
   */
  export type RecurringClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringClass.
     */
    data: XOR<RecurringClassUpdateInput, RecurringClassUncheckedUpdateInput>
    /**
     * Choose, which RecurringClass to update.
     */
    where: RecurringClassWhereUniqueInput
  }

  /**
   * RecurringClass updateMany
   */
  export type RecurringClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringClasses.
     */
    data: XOR<RecurringClassUpdateManyMutationInput, RecurringClassUncheckedUpdateManyInput>
    /**
     * Filter which RecurringClasses to update
     */
    where?: RecurringClassWhereInput
    /**
     * Limit how many RecurringClasses to update.
     */
    limit?: number
  }

  /**
   * RecurringClass updateManyAndReturn
   */
  export type RecurringClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * The data used to update RecurringClasses.
     */
    data: XOR<RecurringClassUpdateManyMutationInput, RecurringClassUncheckedUpdateManyInput>
    /**
     * Filter which RecurringClasses to update
     */
    where?: RecurringClassWhereInput
    /**
     * Limit how many RecurringClasses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringClass upsert
   */
  export type RecurringClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringClass to update in case it exists.
     */
    where: RecurringClassWhereUniqueInput
    /**
     * In case the RecurringClass found by the `where` argument doesn't exist, create a new RecurringClass with this data.
     */
    create: XOR<RecurringClassCreateInput, RecurringClassUncheckedCreateInput>
    /**
     * In case the RecurringClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringClassUpdateInput, RecurringClassUncheckedUpdateInput>
  }

  /**
   * RecurringClass delete
   */
  export type RecurringClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
    /**
     * Filter which RecurringClass to delete.
     */
    where: RecurringClassWhereUniqueInput
  }

  /**
   * RecurringClass deleteMany
   */
  export type RecurringClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringClasses to delete
     */
    where?: RecurringClassWhereInput
    /**
     * Limit how many RecurringClasses to delete.
     */
    limit?: number
  }

  /**
   * RecurringClass.classes
   */
  export type RecurringClass$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Class
     */
    omit?: ClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    cursor?: ClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * RecurringClass.instructor
   */
  export type RecurringClass$instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instructor
     */
    select?: InstructorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instructor
     */
    omit?: InstructorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorInclude<ExtArgs> | null
    where?: InstructorWhereInput
  }

  /**
   * RecurringClass.subscription
   */
  export type RecurringClass$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }

  /**
   * RecurringClass.recurringClassAttendance
   */
  export type RecurringClass$recurringClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    where?: RecurringClassAttendanceWhereInput
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    cursor?: RecurringClassAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringClassAttendanceScalarFieldEnum | RecurringClassAttendanceScalarFieldEnum[]
  }

  /**
   * RecurringClass without action
   */
  export type RecurringClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClass
     */
    select?: RecurringClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClass
     */
    omit?: RecurringClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassInclude<ExtArgs> | null
  }


  /**
   * Model RecurringClassAttendance
   */

  export type AggregateRecurringClassAttendance = {
    _count: RecurringClassAttendanceCountAggregateOutputType | null
    _avg: RecurringClassAttendanceAvgAggregateOutputType | null
    _sum: RecurringClassAttendanceSumAggregateOutputType | null
    _min: RecurringClassAttendanceMinAggregateOutputType | null
    _max: RecurringClassAttendanceMaxAggregateOutputType | null
  }

  export type RecurringClassAttendanceAvgAggregateOutputType = {
    recurringClassId: number | null
    childrenId: number | null
  }

  export type RecurringClassAttendanceSumAggregateOutputType = {
    recurringClassId: number | null
    childrenId: number | null
  }

  export type RecurringClassAttendanceMinAggregateOutputType = {
    recurringClassId: number | null
    childrenId: number | null
  }

  export type RecurringClassAttendanceMaxAggregateOutputType = {
    recurringClassId: number | null
    childrenId: number | null
  }

  export type RecurringClassAttendanceCountAggregateOutputType = {
    recurringClassId: number
    childrenId: number
    _all: number
  }


  export type RecurringClassAttendanceAvgAggregateInputType = {
    recurringClassId?: true
    childrenId?: true
  }

  export type RecurringClassAttendanceSumAggregateInputType = {
    recurringClassId?: true
    childrenId?: true
  }

  export type RecurringClassAttendanceMinAggregateInputType = {
    recurringClassId?: true
    childrenId?: true
  }

  export type RecurringClassAttendanceMaxAggregateInputType = {
    recurringClassId?: true
    childrenId?: true
  }

  export type RecurringClassAttendanceCountAggregateInputType = {
    recurringClassId?: true
    childrenId?: true
    _all?: true
  }

  export type RecurringClassAttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringClassAttendance to aggregate.
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClassAttendances to fetch.
     */
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecurringClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecurringClassAttendances
    **/
    _count?: true | RecurringClassAttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecurringClassAttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecurringClassAttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecurringClassAttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecurringClassAttendanceMaxAggregateInputType
  }

  export type GetRecurringClassAttendanceAggregateType<T extends RecurringClassAttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateRecurringClassAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecurringClassAttendance[P]>
      : GetScalarType<T[P], AggregateRecurringClassAttendance[P]>
  }




  export type RecurringClassAttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecurringClassAttendanceWhereInput
    orderBy?: RecurringClassAttendanceOrderByWithAggregationInput | RecurringClassAttendanceOrderByWithAggregationInput[]
    by: RecurringClassAttendanceScalarFieldEnum[] | RecurringClassAttendanceScalarFieldEnum
    having?: RecurringClassAttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecurringClassAttendanceCountAggregateInputType | true
    _avg?: RecurringClassAttendanceAvgAggregateInputType
    _sum?: RecurringClassAttendanceSumAggregateInputType
    _min?: RecurringClassAttendanceMinAggregateInputType
    _max?: RecurringClassAttendanceMaxAggregateInputType
  }

  export type RecurringClassAttendanceGroupByOutputType = {
    recurringClassId: number
    childrenId: number
    _count: RecurringClassAttendanceCountAggregateOutputType | null
    _avg: RecurringClassAttendanceAvgAggregateOutputType | null
    _sum: RecurringClassAttendanceSumAggregateOutputType | null
    _min: RecurringClassAttendanceMinAggregateOutputType | null
    _max: RecurringClassAttendanceMaxAggregateOutputType | null
  }

  type GetRecurringClassAttendanceGroupByPayload<T extends RecurringClassAttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecurringClassAttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecurringClassAttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecurringClassAttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], RecurringClassAttendanceGroupByOutputType[P]>
        }
      >
    >


  export type RecurringClassAttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurringClassId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClassAttendance"]>

  export type RecurringClassAttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurringClassId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClassAttendance"]>

  export type RecurringClassAttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recurringClassId?: boolean
    childrenId?: boolean
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recurringClassAttendance"]>

  export type RecurringClassAttendanceSelectScalar = {
    recurringClassId?: boolean
    childrenId?: boolean
  }

  export type RecurringClassAttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"recurringClassId" | "childrenId", ExtArgs["result"]["recurringClassAttendance"]>
  export type RecurringClassAttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }
  export type RecurringClassAttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }
  export type RecurringClassAttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ChildDefaultArgs<ExtArgs>
    recurringClass?: boolean | RecurringClassDefaultArgs<ExtArgs>
  }

  export type $RecurringClassAttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecurringClassAttendance"
    objects: {
      children: Prisma.$ChildPayload<ExtArgs>
      recurringClass: Prisma.$RecurringClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recurringClassId: number
      childrenId: number
    }, ExtArgs["result"]["recurringClassAttendance"]>
    composites: {}
  }

  type RecurringClassAttendanceGetPayload<S extends boolean | null | undefined | RecurringClassAttendanceDefaultArgs> = $Result.GetResult<Prisma.$RecurringClassAttendancePayload, S>

  type RecurringClassAttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RecurringClassAttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecurringClassAttendanceCountAggregateInputType | true
    }

  export interface RecurringClassAttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecurringClassAttendance'], meta: { name: 'RecurringClassAttendance' } }
    /**
     * Find zero or one RecurringClassAttendance that matches the filter.
     * @param {RecurringClassAttendanceFindUniqueArgs} args - Arguments to find a RecurringClassAttendance
     * @example
     * // Get one RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecurringClassAttendanceFindUniqueArgs>(args: SelectSubset<T, RecurringClassAttendanceFindUniqueArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RecurringClassAttendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RecurringClassAttendanceFindUniqueOrThrowArgs} args - Arguments to find a RecurringClassAttendance
     * @example
     * // Get one RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecurringClassAttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, RecurringClassAttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringClassAttendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceFindFirstArgs} args - Arguments to find a RecurringClassAttendance
     * @example
     * // Get one RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecurringClassAttendanceFindFirstArgs>(args?: SelectSubset<T, RecurringClassAttendanceFindFirstArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RecurringClassAttendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceFindFirstOrThrowArgs} args - Arguments to find a RecurringClassAttendance
     * @example
     * // Get one RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecurringClassAttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, RecurringClassAttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RecurringClassAttendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecurringClassAttendances
     * const recurringClassAttendances = await prisma.recurringClassAttendance.findMany()
     * 
     * // Get first 10 RecurringClassAttendances
     * const recurringClassAttendances = await prisma.recurringClassAttendance.findMany({ take: 10 })
     * 
     * // Only select the `recurringClassId`
     * const recurringClassAttendanceWithRecurringClassIdOnly = await prisma.recurringClassAttendance.findMany({ select: { recurringClassId: true } })
     * 
     */
    findMany<T extends RecurringClassAttendanceFindManyArgs>(args?: SelectSubset<T, RecurringClassAttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RecurringClassAttendance.
     * @param {RecurringClassAttendanceCreateArgs} args - Arguments to create a RecurringClassAttendance.
     * @example
     * // Create one RecurringClassAttendance
     * const RecurringClassAttendance = await prisma.recurringClassAttendance.create({
     *   data: {
     *     // ... data to create a RecurringClassAttendance
     *   }
     * })
     * 
     */
    create<T extends RecurringClassAttendanceCreateArgs>(args: SelectSubset<T, RecurringClassAttendanceCreateArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RecurringClassAttendances.
     * @param {RecurringClassAttendanceCreateManyArgs} args - Arguments to create many RecurringClassAttendances.
     * @example
     * // Create many RecurringClassAttendances
     * const recurringClassAttendance = await prisma.recurringClassAttendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecurringClassAttendanceCreateManyArgs>(args?: SelectSubset<T, RecurringClassAttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RecurringClassAttendances and returns the data saved in the database.
     * @param {RecurringClassAttendanceCreateManyAndReturnArgs} args - Arguments to create many RecurringClassAttendances.
     * @example
     * // Create many RecurringClassAttendances
     * const recurringClassAttendance = await prisma.recurringClassAttendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RecurringClassAttendances and only return the `recurringClassId`
     * const recurringClassAttendanceWithRecurringClassIdOnly = await prisma.recurringClassAttendance.createManyAndReturn({
     *   select: { recurringClassId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RecurringClassAttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, RecurringClassAttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RecurringClassAttendance.
     * @param {RecurringClassAttendanceDeleteArgs} args - Arguments to delete one RecurringClassAttendance.
     * @example
     * // Delete one RecurringClassAttendance
     * const RecurringClassAttendance = await prisma.recurringClassAttendance.delete({
     *   where: {
     *     // ... filter to delete one RecurringClassAttendance
     *   }
     * })
     * 
     */
    delete<T extends RecurringClassAttendanceDeleteArgs>(args: SelectSubset<T, RecurringClassAttendanceDeleteArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RecurringClassAttendance.
     * @param {RecurringClassAttendanceUpdateArgs} args - Arguments to update one RecurringClassAttendance.
     * @example
     * // Update one RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecurringClassAttendanceUpdateArgs>(args: SelectSubset<T, RecurringClassAttendanceUpdateArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RecurringClassAttendances.
     * @param {RecurringClassAttendanceDeleteManyArgs} args - Arguments to filter RecurringClassAttendances to delete.
     * @example
     * // Delete a few RecurringClassAttendances
     * const { count } = await prisma.recurringClassAttendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecurringClassAttendanceDeleteManyArgs>(args?: SelectSubset<T, RecurringClassAttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringClassAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecurringClassAttendances
     * const recurringClassAttendance = await prisma.recurringClassAttendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecurringClassAttendanceUpdateManyArgs>(args: SelectSubset<T, RecurringClassAttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecurringClassAttendances and returns the data updated in the database.
     * @param {RecurringClassAttendanceUpdateManyAndReturnArgs} args - Arguments to update many RecurringClassAttendances.
     * @example
     * // Update many RecurringClassAttendances
     * const recurringClassAttendance = await prisma.recurringClassAttendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RecurringClassAttendances and only return the `recurringClassId`
     * const recurringClassAttendanceWithRecurringClassIdOnly = await prisma.recurringClassAttendance.updateManyAndReturn({
     *   select: { recurringClassId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RecurringClassAttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, RecurringClassAttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RecurringClassAttendance.
     * @param {RecurringClassAttendanceUpsertArgs} args - Arguments to update or create a RecurringClassAttendance.
     * @example
     * // Update or create a RecurringClassAttendance
     * const recurringClassAttendance = await prisma.recurringClassAttendance.upsert({
     *   create: {
     *     // ... data to create a RecurringClassAttendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecurringClassAttendance we want to update
     *   }
     * })
     */
    upsert<T extends RecurringClassAttendanceUpsertArgs>(args: SelectSubset<T, RecurringClassAttendanceUpsertArgs<ExtArgs>>): Prisma__RecurringClassAttendanceClient<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RecurringClassAttendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceCountArgs} args - Arguments to filter RecurringClassAttendances to count.
     * @example
     * // Count the number of RecurringClassAttendances
     * const count = await prisma.recurringClassAttendance.count({
     *   where: {
     *     // ... the filter for the RecurringClassAttendances we want to count
     *   }
     * })
    **/
    count<T extends RecurringClassAttendanceCountArgs>(
      args?: Subset<T, RecurringClassAttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecurringClassAttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecurringClassAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecurringClassAttendanceAggregateArgs>(args: Subset<T, RecurringClassAttendanceAggregateArgs>): Prisma.PrismaPromise<GetRecurringClassAttendanceAggregateType<T>>

    /**
     * Group by RecurringClassAttendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecurringClassAttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecurringClassAttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecurringClassAttendanceGroupByArgs['orderBy'] }
        : { orderBy?: RecurringClassAttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecurringClassAttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecurringClassAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecurringClassAttendance model
   */
  readonly fields: RecurringClassAttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecurringClassAttendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecurringClassAttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    children<T extends ChildDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChildDefaultArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    recurringClass<T extends RecurringClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecurringClassDefaultArgs<ExtArgs>>): Prisma__RecurringClassClient<$Result.GetResult<Prisma.$RecurringClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RecurringClassAttendance model
   */
  interface RecurringClassAttendanceFieldRefs {
    readonly recurringClassId: FieldRef<"RecurringClassAttendance", 'Int'>
    readonly childrenId: FieldRef<"RecurringClassAttendance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RecurringClassAttendance findUnique
   */
  export type RecurringClassAttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClassAttendance to fetch.
     */
    where: RecurringClassAttendanceWhereUniqueInput
  }

  /**
   * RecurringClassAttendance findUniqueOrThrow
   */
  export type RecurringClassAttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClassAttendance to fetch.
     */
    where: RecurringClassAttendanceWhereUniqueInput
  }

  /**
   * RecurringClassAttendance findFirst
   */
  export type RecurringClassAttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClassAttendance to fetch.
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClassAttendances to fetch.
     */
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringClassAttendances.
     */
    cursor?: RecurringClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringClassAttendances.
     */
    distinct?: RecurringClassAttendanceScalarFieldEnum | RecurringClassAttendanceScalarFieldEnum[]
  }

  /**
   * RecurringClassAttendance findFirstOrThrow
   */
  export type RecurringClassAttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClassAttendance to fetch.
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClassAttendances to fetch.
     */
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecurringClassAttendances.
     */
    cursor?: RecurringClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClassAttendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecurringClassAttendances.
     */
    distinct?: RecurringClassAttendanceScalarFieldEnum | RecurringClassAttendanceScalarFieldEnum[]
  }

  /**
   * RecurringClassAttendance findMany
   */
  export type RecurringClassAttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter, which RecurringClassAttendances to fetch.
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecurringClassAttendances to fetch.
     */
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecurringClassAttendances.
     */
    cursor?: RecurringClassAttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecurringClassAttendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecurringClassAttendances.
     */
    skip?: number
    distinct?: RecurringClassAttendanceScalarFieldEnum | RecurringClassAttendanceScalarFieldEnum[]
  }

  /**
   * RecurringClassAttendance create
   */
  export type RecurringClassAttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a RecurringClassAttendance.
     */
    data: XOR<RecurringClassAttendanceCreateInput, RecurringClassAttendanceUncheckedCreateInput>
  }

  /**
   * RecurringClassAttendance createMany
   */
  export type RecurringClassAttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecurringClassAttendances.
     */
    data: RecurringClassAttendanceCreateManyInput | RecurringClassAttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RecurringClassAttendance createManyAndReturn
   */
  export type RecurringClassAttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many RecurringClassAttendances.
     */
    data: RecurringClassAttendanceCreateManyInput | RecurringClassAttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringClassAttendance update
   */
  export type RecurringClassAttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a RecurringClassAttendance.
     */
    data: XOR<RecurringClassAttendanceUpdateInput, RecurringClassAttendanceUncheckedUpdateInput>
    /**
     * Choose, which RecurringClassAttendance to update.
     */
    where: RecurringClassAttendanceWhereUniqueInput
  }

  /**
   * RecurringClassAttendance updateMany
   */
  export type RecurringClassAttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecurringClassAttendances.
     */
    data: XOR<RecurringClassAttendanceUpdateManyMutationInput, RecurringClassAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RecurringClassAttendances to update
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * Limit how many RecurringClassAttendances to update.
     */
    limit?: number
  }

  /**
   * RecurringClassAttendance updateManyAndReturn
   */
  export type RecurringClassAttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * The data used to update RecurringClassAttendances.
     */
    data: XOR<RecurringClassAttendanceUpdateManyMutationInput, RecurringClassAttendanceUncheckedUpdateManyInput>
    /**
     * Filter which RecurringClassAttendances to update
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * Limit how many RecurringClassAttendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RecurringClassAttendance upsert
   */
  export type RecurringClassAttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the RecurringClassAttendance to update in case it exists.
     */
    where: RecurringClassAttendanceWhereUniqueInput
    /**
     * In case the RecurringClassAttendance found by the `where` argument doesn't exist, create a new RecurringClassAttendance with this data.
     */
    create: XOR<RecurringClassAttendanceCreateInput, RecurringClassAttendanceUncheckedCreateInput>
    /**
     * In case the RecurringClassAttendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecurringClassAttendanceUpdateInput, RecurringClassAttendanceUncheckedUpdateInput>
  }

  /**
   * RecurringClassAttendance delete
   */
  export type RecurringClassAttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    /**
     * Filter which RecurringClassAttendance to delete.
     */
    where: RecurringClassAttendanceWhereUniqueInput
  }

  /**
   * RecurringClassAttendance deleteMany
   */
  export type RecurringClassAttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecurringClassAttendances to delete
     */
    where?: RecurringClassAttendanceWhereInput
    /**
     * Limit how many RecurringClassAttendances to delete.
     */
    limit?: number
  }

  /**
   * RecurringClassAttendance without action
   */
  export type RecurringClassAttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    id: number | null
    eventId: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    id: number | null
    eventId: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: number | null
    date: Date | null
    eventId: number | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    eventId: number | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    date: number
    eventId: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    id?: true
    eventId?: true
  }

  export type ScheduleSumAggregateInputType = {
    id?: true
    eventId?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    date?: true
    eventId?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    date?: true
    eventId?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    date?: true
    eventId?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: number
    date: Date
    eventId: number
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    eventId?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    eventId?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    eventId?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    date?: boolean
    eventId?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "eventId", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      eventId: number
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'Int'>
    readonly date: FieldRef<"Schedule", 'DateTime'>
    readonly eventId: FieldRef<"Schedule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    id: number | null
  }

  export type EventSumAggregateOutputType = {
    id: number | null
  }

  export type EventMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    color: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    id?: true
  }

  export type EventSumAggregateInputType = {
    id?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: number
    name: string
    color: string
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    Schedule?: boolean | Event$ScheduleArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Schedule?: boolean | Event$ScheduleArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      Schedule: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Schedule<T extends Event$ScheduleArgs<ExtArgs> = {}>(args?: Subset<T, Event$ScheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'Int'>
    readonly name: FieldRef<"Event", 'String'>
    readonly color: FieldRef<"Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.Schedule
   */
  export type Event$ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model InstructorSchedule
   */

  export type AggregateInstructorSchedule = {
    _count: InstructorScheduleCountAggregateOutputType | null
    _avg: InstructorScheduleAvgAggregateOutputType | null
    _sum: InstructorScheduleSumAggregateOutputType | null
    _min: InstructorScheduleMinAggregateOutputType | null
    _max: InstructorScheduleMaxAggregateOutputType | null
  }

  export type InstructorScheduleAvgAggregateOutputType = {
    id: number | null
    instructorId: number | null
  }

  export type InstructorScheduleSumAggregateOutputType = {
    id: number | null
    instructorId: number | null
  }

  export type InstructorScheduleMinAggregateOutputType = {
    id: number | null
    instructorId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    timezone: string | null
  }

  export type InstructorScheduleMaxAggregateOutputType = {
    id: number | null
    instructorId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    timezone: string | null
  }

  export type InstructorScheduleCountAggregateOutputType = {
    id: number
    instructorId: number
    effectiveFrom: number
    effectiveTo: number
    timezone: number
    _all: number
  }


  export type InstructorScheduleAvgAggregateInputType = {
    id?: true
    instructorId?: true
  }

  export type InstructorScheduleSumAggregateInputType = {
    id?: true
    instructorId?: true
  }

  export type InstructorScheduleMinAggregateInputType = {
    id?: true
    instructorId?: true
    effectiveFrom?: true
    effectiveTo?: true
    timezone?: true
  }

  export type InstructorScheduleMaxAggregateInputType = {
    id?: true
    instructorId?: true
    effectiveFrom?: true
    effectiveTo?: true
    timezone?: true
  }

  export type InstructorScheduleCountAggregateInputType = {
    id?: true
    instructorId?: true
    effectiveFrom?: true
    effectiveTo?: true
    timezone?: true
    _all?: true
  }

  export type InstructorScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorSchedule to aggregate.
     */
    where?: InstructorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSchedules to fetch.
     */
    orderBy?: InstructorScheduleOrderByWithRelationInput | InstructorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstructorSchedules
    **/
    _count?: true | InstructorScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorScheduleMaxAggregateInputType
  }

  export type GetInstructorScheduleAggregateType<T extends InstructorScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructorSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructorSchedule[P]>
      : GetScalarType<T[P], AggregateInstructorSchedule[P]>
  }




  export type InstructorScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorScheduleWhereInput
    orderBy?: InstructorScheduleOrderByWithAggregationInput | InstructorScheduleOrderByWithAggregationInput[]
    by: InstructorScheduleScalarFieldEnum[] | InstructorScheduleScalarFieldEnum
    having?: InstructorScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorScheduleCountAggregateInputType | true
    _avg?: InstructorScheduleAvgAggregateInputType
    _sum?: InstructorScheduleSumAggregateInputType
    _min?: InstructorScheduleMinAggregateInputType
    _max?: InstructorScheduleMaxAggregateInputType
  }

  export type InstructorScheduleGroupByOutputType = {
    id: number
    instructorId: number
    effectiveFrom: Date
    effectiveTo: Date | null
    timezone: string
    _count: InstructorScheduleCountAggregateOutputType | null
    _avg: InstructorScheduleAvgAggregateOutputType | null
    _sum: InstructorScheduleSumAggregateOutputType | null
    _min: InstructorScheduleMinAggregateOutputType | null
    _max: InstructorScheduleMaxAggregateOutputType | null
  }

  type GetInstructorScheduleGroupByPayload<T extends InstructorScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorScheduleGroupByOutputType[P]>
        }
      >
    >


  export type InstructorScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    timezone?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
    slots?: boolean | InstructorSchedule$slotsArgs<ExtArgs>
    _count?: boolean | InstructorScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSchedule"]>

  export type InstructorScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    timezone?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSchedule"]>

  export type InstructorScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instructorId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    timezone?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSchedule"]>

  export type InstructorScheduleSelectScalar = {
    id?: boolean
    instructorId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    timezone?: boolean
  }

  export type InstructorScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instructorId" | "effectiveFrom" | "effectiveTo" | "timezone", ExtArgs["result"]["instructorSchedule"]>
  export type InstructorScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
    slots?: boolean | InstructorSchedule$slotsArgs<ExtArgs>
    _count?: boolean | InstructorScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstructorScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }
  export type InstructorScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }

  export type $InstructorSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstructorSchedule"
    objects: {
      instructor: Prisma.$InstructorPayload<ExtArgs>
      slots: Prisma.$InstructorSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instructorId: number
      effectiveFrom: Date
      effectiveTo: Date | null
      timezone: string
    }, ExtArgs["result"]["instructorSchedule"]>
    composites: {}
  }

  type InstructorScheduleGetPayload<S extends boolean | null | undefined | InstructorScheduleDefaultArgs> = $Result.GetResult<Prisma.$InstructorSchedulePayload, S>

  type InstructorScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstructorScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstructorScheduleCountAggregateInputType | true
    }

  export interface InstructorScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstructorSchedule'], meta: { name: 'InstructorSchedule' } }
    /**
     * Find zero or one InstructorSchedule that matches the filter.
     * @param {InstructorScheduleFindUniqueArgs} args - Arguments to find a InstructorSchedule
     * @example
     * // Get one InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorScheduleFindUniqueArgs>(args: SelectSubset<T, InstructorScheduleFindUniqueArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstructorSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstructorScheduleFindUniqueOrThrowArgs} args - Arguments to find a InstructorSchedule
     * @example
     * // Get one InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleFindFirstArgs} args - Arguments to find a InstructorSchedule
     * @example
     * // Get one InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorScheduleFindFirstArgs>(args?: SelectSubset<T, InstructorScheduleFindFirstArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleFindFirstOrThrowArgs} args - Arguments to find a InstructorSchedule
     * @example
     * // Get one InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstructorSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstructorSchedules
     * const instructorSchedules = await prisma.instructorSchedule.findMany()
     * 
     * // Get first 10 InstructorSchedules
     * const instructorSchedules = await prisma.instructorSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instructorScheduleWithIdOnly = await prisma.instructorSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstructorScheduleFindManyArgs>(args?: SelectSubset<T, InstructorScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstructorSchedule.
     * @param {InstructorScheduleCreateArgs} args - Arguments to create a InstructorSchedule.
     * @example
     * // Create one InstructorSchedule
     * const InstructorSchedule = await prisma.instructorSchedule.create({
     *   data: {
     *     // ... data to create a InstructorSchedule
     *   }
     * })
     * 
     */
    create<T extends InstructorScheduleCreateArgs>(args: SelectSubset<T, InstructorScheduleCreateArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstructorSchedules.
     * @param {InstructorScheduleCreateManyArgs} args - Arguments to create many InstructorSchedules.
     * @example
     * // Create many InstructorSchedules
     * const instructorSchedule = await prisma.instructorSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorScheduleCreateManyArgs>(args?: SelectSubset<T, InstructorScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstructorSchedules and returns the data saved in the database.
     * @param {InstructorScheduleCreateManyAndReturnArgs} args - Arguments to create many InstructorSchedules.
     * @example
     * // Create many InstructorSchedules
     * const instructorSchedule = await prisma.instructorSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstructorSchedules and only return the `id`
     * const instructorScheduleWithIdOnly = await prisma.instructorSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstructorSchedule.
     * @param {InstructorScheduleDeleteArgs} args - Arguments to delete one InstructorSchedule.
     * @example
     * // Delete one InstructorSchedule
     * const InstructorSchedule = await prisma.instructorSchedule.delete({
     *   where: {
     *     // ... filter to delete one InstructorSchedule
     *   }
     * })
     * 
     */
    delete<T extends InstructorScheduleDeleteArgs>(args: SelectSubset<T, InstructorScheduleDeleteArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstructorSchedule.
     * @param {InstructorScheduleUpdateArgs} args - Arguments to update one InstructorSchedule.
     * @example
     * // Update one InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorScheduleUpdateArgs>(args: SelectSubset<T, InstructorScheduleUpdateArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstructorSchedules.
     * @param {InstructorScheduleDeleteManyArgs} args - Arguments to filter InstructorSchedules to delete.
     * @example
     * // Delete a few InstructorSchedules
     * const { count } = await prisma.instructorSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorScheduleDeleteManyArgs>(args?: SelectSubset<T, InstructorScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstructorSchedules
     * const instructorSchedule = await prisma.instructorSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorScheduleUpdateManyArgs>(args: SelectSubset<T, InstructorScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorSchedules and returns the data updated in the database.
     * @param {InstructorScheduleUpdateManyAndReturnArgs} args - Arguments to update many InstructorSchedules.
     * @example
     * // Update many InstructorSchedules
     * const instructorSchedule = await prisma.instructorSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstructorSchedules and only return the `id`
     * const instructorScheduleWithIdOnly = await prisma.instructorSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstructorScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, InstructorScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstructorSchedule.
     * @param {InstructorScheduleUpsertArgs} args - Arguments to update or create a InstructorSchedule.
     * @example
     * // Update or create a InstructorSchedule
     * const instructorSchedule = await prisma.instructorSchedule.upsert({
     *   create: {
     *     // ... data to create a InstructorSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstructorSchedule we want to update
     *   }
     * })
     */
    upsert<T extends InstructorScheduleUpsertArgs>(args: SelectSubset<T, InstructorScheduleUpsertArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstructorSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleCountArgs} args - Arguments to filter InstructorSchedules to count.
     * @example
     * // Count the number of InstructorSchedules
     * const count = await prisma.instructorSchedule.count({
     *   where: {
     *     // ... the filter for the InstructorSchedules we want to count
     *   }
     * })
    **/
    count<T extends InstructorScheduleCountArgs>(
      args?: Subset<T, InstructorScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstructorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorScheduleAggregateArgs>(args: Subset<T, InstructorScheduleAggregateArgs>): Prisma.PrismaPromise<GetInstructorScheduleAggregateType<T>>

    /**
     * Group by InstructorSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorScheduleGroupByArgs['orderBy'] }
        : { orderBy?: InstructorScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstructorSchedule model
   */
  readonly fields: InstructorScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstructorSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends InstructorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructorDefaultArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slots<T extends InstructorSchedule$slotsArgs<ExtArgs> = {}>(args?: Subset<T, InstructorSchedule$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstructorSchedule model
   */
  interface InstructorScheduleFieldRefs {
    readonly id: FieldRef<"InstructorSchedule", 'Int'>
    readonly instructorId: FieldRef<"InstructorSchedule", 'Int'>
    readonly effectiveFrom: FieldRef<"InstructorSchedule", 'DateTime'>
    readonly effectiveTo: FieldRef<"InstructorSchedule", 'DateTime'>
    readonly timezone: FieldRef<"InstructorSchedule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InstructorSchedule findUnique
   */
  export type InstructorScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSchedule to fetch.
     */
    where: InstructorScheduleWhereUniqueInput
  }

  /**
   * InstructorSchedule findUniqueOrThrow
   */
  export type InstructorScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSchedule to fetch.
     */
    where: InstructorScheduleWhereUniqueInput
  }

  /**
   * InstructorSchedule findFirst
   */
  export type InstructorScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSchedule to fetch.
     */
    where?: InstructorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSchedules to fetch.
     */
    orderBy?: InstructorScheduleOrderByWithRelationInput | InstructorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorSchedules.
     */
    cursor?: InstructorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorSchedules.
     */
    distinct?: InstructorScheduleScalarFieldEnum | InstructorScheduleScalarFieldEnum[]
  }

  /**
   * InstructorSchedule findFirstOrThrow
   */
  export type InstructorScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSchedule to fetch.
     */
    where?: InstructorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSchedules to fetch.
     */
    orderBy?: InstructorScheduleOrderByWithRelationInput | InstructorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorSchedules.
     */
    cursor?: InstructorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorSchedules.
     */
    distinct?: InstructorScheduleScalarFieldEnum | InstructorScheduleScalarFieldEnum[]
  }

  /**
   * InstructorSchedule findMany
   */
  export type InstructorScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSchedules to fetch.
     */
    where?: InstructorScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSchedules to fetch.
     */
    orderBy?: InstructorScheduleOrderByWithRelationInput | InstructorScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstructorSchedules.
     */
    cursor?: InstructorScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSchedules.
     */
    skip?: number
    distinct?: InstructorScheduleScalarFieldEnum | InstructorScheduleScalarFieldEnum[]
  }

  /**
   * InstructorSchedule create
   */
  export type InstructorScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a InstructorSchedule.
     */
    data: XOR<InstructorScheduleCreateInput, InstructorScheduleUncheckedCreateInput>
  }

  /**
   * InstructorSchedule createMany
   */
  export type InstructorScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstructorSchedules.
     */
    data: InstructorScheduleCreateManyInput | InstructorScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstructorSchedule createManyAndReturn
   */
  export type InstructorScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many InstructorSchedules.
     */
    data: InstructorScheduleCreateManyInput | InstructorScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorSchedule update
   */
  export type InstructorScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a InstructorSchedule.
     */
    data: XOR<InstructorScheduleUpdateInput, InstructorScheduleUncheckedUpdateInput>
    /**
     * Choose, which InstructorSchedule to update.
     */
    where: InstructorScheduleWhereUniqueInput
  }

  /**
   * InstructorSchedule updateMany
   */
  export type InstructorScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstructorSchedules.
     */
    data: XOR<InstructorScheduleUpdateManyMutationInput, InstructorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which InstructorSchedules to update
     */
    where?: InstructorScheduleWhereInput
    /**
     * Limit how many InstructorSchedules to update.
     */
    limit?: number
  }

  /**
   * InstructorSchedule updateManyAndReturn
   */
  export type InstructorScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * The data used to update InstructorSchedules.
     */
    data: XOR<InstructorScheduleUpdateManyMutationInput, InstructorScheduleUncheckedUpdateManyInput>
    /**
     * Filter which InstructorSchedules to update
     */
    where?: InstructorScheduleWhereInput
    /**
     * Limit how many InstructorSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorSchedule upsert
   */
  export type InstructorScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the InstructorSchedule to update in case it exists.
     */
    where: InstructorScheduleWhereUniqueInput
    /**
     * In case the InstructorSchedule found by the `where` argument doesn't exist, create a new InstructorSchedule with this data.
     */
    create: XOR<InstructorScheduleCreateInput, InstructorScheduleUncheckedCreateInput>
    /**
     * In case the InstructorSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorScheduleUpdateInput, InstructorScheduleUncheckedUpdateInput>
  }

  /**
   * InstructorSchedule delete
   */
  export type InstructorScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
    /**
     * Filter which InstructorSchedule to delete.
     */
    where: InstructorScheduleWhereUniqueInput
  }

  /**
   * InstructorSchedule deleteMany
   */
  export type InstructorScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorSchedules to delete
     */
    where?: InstructorScheduleWhereInput
    /**
     * Limit how many InstructorSchedules to delete.
     */
    limit?: number
  }

  /**
   * InstructorSchedule.slots
   */
  export type InstructorSchedule$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    where?: InstructorSlotWhereInput
    orderBy?: InstructorSlotOrderByWithRelationInput | InstructorSlotOrderByWithRelationInput[]
    cursor?: InstructorSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructorSlotScalarFieldEnum | InstructorSlotScalarFieldEnum[]
  }

  /**
   * InstructorSchedule without action
   */
  export type InstructorScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSchedule
     */
    select?: InstructorScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSchedule
     */
    omit?: InstructorScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorScheduleInclude<ExtArgs> | null
  }


  /**
   * Model InstructorSlot
   */

  export type AggregateInstructorSlot = {
    _count: InstructorSlotCountAggregateOutputType | null
    _avg: InstructorSlotAvgAggregateOutputType | null
    _sum: InstructorSlotSumAggregateOutputType | null
    _min: InstructorSlotMinAggregateOutputType | null
    _max: InstructorSlotMaxAggregateOutputType | null
  }

  export type InstructorSlotAvgAggregateOutputType = {
    scheduleId: number | null
    weekday: number | null
  }

  export type InstructorSlotSumAggregateOutputType = {
    scheduleId: number | null
    weekday: number | null
  }

  export type InstructorSlotMinAggregateOutputType = {
    scheduleId: number | null
    weekday: number | null
    startTime: Date | null
  }

  export type InstructorSlotMaxAggregateOutputType = {
    scheduleId: number | null
    weekday: number | null
    startTime: Date | null
  }

  export type InstructorSlotCountAggregateOutputType = {
    scheduleId: number
    weekday: number
    startTime: number
    _all: number
  }


  export type InstructorSlotAvgAggregateInputType = {
    scheduleId?: true
    weekday?: true
  }

  export type InstructorSlotSumAggregateInputType = {
    scheduleId?: true
    weekday?: true
  }

  export type InstructorSlotMinAggregateInputType = {
    scheduleId?: true
    weekday?: true
    startTime?: true
  }

  export type InstructorSlotMaxAggregateInputType = {
    scheduleId?: true
    weekday?: true
    startTime?: true
  }

  export type InstructorSlotCountAggregateInputType = {
    scheduleId?: true
    weekday?: true
    startTime?: true
    _all?: true
  }

  export type InstructorSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorSlot to aggregate.
     */
    where?: InstructorSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSlots to fetch.
     */
    orderBy?: InstructorSlotOrderByWithRelationInput | InstructorSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstructorSlots
    **/
    _count?: true | InstructorSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorSlotMaxAggregateInputType
  }

  export type GetInstructorSlotAggregateType<T extends InstructorSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructorSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructorSlot[P]>
      : GetScalarType<T[P], AggregateInstructorSlot[P]>
  }




  export type InstructorSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorSlotWhereInput
    orderBy?: InstructorSlotOrderByWithAggregationInput | InstructorSlotOrderByWithAggregationInput[]
    by: InstructorSlotScalarFieldEnum[] | InstructorSlotScalarFieldEnum
    having?: InstructorSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorSlotCountAggregateInputType | true
    _avg?: InstructorSlotAvgAggregateInputType
    _sum?: InstructorSlotSumAggregateInputType
    _min?: InstructorSlotMinAggregateInputType
    _max?: InstructorSlotMaxAggregateInputType
  }

  export type InstructorSlotGroupByOutputType = {
    scheduleId: number
    weekday: number
    startTime: Date
    _count: InstructorSlotCountAggregateOutputType | null
    _avg: InstructorSlotAvgAggregateOutputType | null
    _sum: InstructorSlotSumAggregateOutputType | null
    _min: InstructorSlotMinAggregateOutputType | null
    _max: InstructorSlotMaxAggregateOutputType | null
  }

  type GetInstructorSlotGroupByPayload<T extends InstructorSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorSlotGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorSlotGroupByOutputType[P]>
        }
      >
    >


  export type InstructorSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    weekday?: boolean
    startTime?: boolean
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSlot"]>

  export type InstructorSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    weekday?: boolean
    startTime?: boolean
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSlot"]>

  export type InstructorSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scheduleId?: boolean
    weekday?: boolean
    startTime?: boolean
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorSlot"]>

  export type InstructorSlotSelectScalar = {
    scheduleId?: boolean
    weekday?: boolean
    startTime?: boolean
  }

  export type InstructorSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"scheduleId" | "weekday" | "startTime", ExtArgs["result"]["instructorSlot"]>
  export type InstructorSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }
  export type InstructorSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }
  export type InstructorSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | InstructorScheduleDefaultArgs<ExtArgs>
  }

  export type $InstructorSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstructorSlot"
    objects: {
      schedule: Prisma.$InstructorSchedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      scheduleId: number
      weekday: number
      startTime: Date
    }, ExtArgs["result"]["instructorSlot"]>
    composites: {}
  }

  type InstructorSlotGetPayload<S extends boolean | null | undefined | InstructorSlotDefaultArgs> = $Result.GetResult<Prisma.$InstructorSlotPayload, S>

  type InstructorSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstructorSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstructorSlotCountAggregateInputType | true
    }

  export interface InstructorSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstructorSlot'], meta: { name: 'InstructorSlot' } }
    /**
     * Find zero or one InstructorSlot that matches the filter.
     * @param {InstructorSlotFindUniqueArgs} args - Arguments to find a InstructorSlot
     * @example
     * // Get one InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorSlotFindUniqueArgs>(args: SelectSubset<T, InstructorSlotFindUniqueArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstructorSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstructorSlotFindUniqueOrThrowArgs} args - Arguments to find a InstructorSlot
     * @example
     * // Get one InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotFindFirstArgs} args - Arguments to find a InstructorSlot
     * @example
     * // Get one InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorSlotFindFirstArgs>(args?: SelectSubset<T, InstructorSlotFindFirstArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotFindFirstOrThrowArgs} args - Arguments to find a InstructorSlot
     * @example
     * // Get one InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstructorSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstructorSlots
     * const instructorSlots = await prisma.instructorSlot.findMany()
     * 
     * // Get first 10 InstructorSlots
     * const instructorSlots = await prisma.instructorSlot.findMany({ take: 10 })
     * 
     * // Only select the `scheduleId`
     * const instructorSlotWithScheduleIdOnly = await prisma.instructorSlot.findMany({ select: { scheduleId: true } })
     * 
     */
    findMany<T extends InstructorSlotFindManyArgs>(args?: SelectSubset<T, InstructorSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstructorSlot.
     * @param {InstructorSlotCreateArgs} args - Arguments to create a InstructorSlot.
     * @example
     * // Create one InstructorSlot
     * const InstructorSlot = await prisma.instructorSlot.create({
     *   data: {
     *     // ... data to create a InstructorSlot
     *   }
     * })
     * 
     */
    create<T extends InstructorSlotCreateArgs>(args: SelectSubset<T, InstructorSlotCreateArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstructorSlots.
     * @param {InstructorSlotCreateManyArgs} args - Arguments to create many InstructorSlots.
     * @example
     * // Create many InstructorSlots
     * const instructorSlot = await prisma.instructorSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorSlotCreateManyArgs>(args?: SelectSubset<T, InstructorSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstructorSlots and returns the data saved in the database.
     * @param {InstructorSlotCreateManyAndReturnArgs} args - Arguments to create many InstructorSlots.
     * @example
     * // Create many InstructorSlots
     * const instructorSlot = await prisma.instructorSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstructorSlots and only return the `scheduleId`
     * const instructorSlotWithScheduleIdOnly = await prisma.instructorSlot.createManyAndReturn({
     *   select: { scheduleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstructorSlot.
     * @param {InstructorSlotDeleteArgs} args - Arguments to delete one InstructorSlot.
     * @example
     * // Delete one InstructorSlot
     * const InstructorSlot = await prisma.instructorSlot.delete({
     *   where: {
     *     // ... filter to delete one InstructorSlot
     *   }
     * })
     * 
     */
    delete<T extends InstructorSlotDeleteArgs>(args: SelectSubset<T, InstructorSlotDeleteArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstructorSlot.
     * @param {InstructorSlotUpdateArgs} args - Arguments to update one InstructorSlot.
     * @example
     * // Update one InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorSlotUpdateArgs>(args: SelectSubset<T, InstructorSlotUpdateArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstructorSlots.
     * @param {InstructorSlotDeleteManyArgs} args - Arguments to filter InstructorSlots to delete.
     * @example
     * // Delete a few InstructorSlots
     * const { count } = await prisma.instructorSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorSlotDeleteManyArgs>(args?: SelectSubset<T, InstructorSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstructorSlots
     * const instructorSlot = await prisma.instructorSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorSlotUpdateManyArgs>(args: SelectSubset<T, InstructorSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorSlots and returns the data updated in the database.
     * @param {InstructorSlotUpdateManyAndReturnArgs} args - Arguments to update many InstructorSlots.
     * @example
     * // Update many InstructorSlots
     * const instructorSlot = await prisma.instructorSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstructorSlots and only return the `scheduleId`
     * const instructorSlotWithScheduleIdOnly = await prisma.instructorSlot.updateManyAndReturn({
     *   select: { scheduleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstructorSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, InstructorSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstructorSlot.
     * @param {InstructorSlotUpsertArgs} args - Arguments to update or create a InstructorSlot.
     * @example
     * // Update or create a InstructorSlot
     * const instructorSlot = await prisma.instructorSlot.upsert({
     *   create: {
     *     // ... data to create a InstructorSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstructorSlot we want to update
     *   }
     * })
     */
    upsert<T extends InstructorSlotUpsertArgs>(args: SelectSubset<T, InstructorSlotUpsertArgs<ExtArgs>>): Prisma__InstructorSlotClient<$Result.GetResult<Prisma.$InstructorSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstructorSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotCountArgs} args - Arguments to filter InstructorSlots to count.
     * @example
     * // Count the number of InstructorSlots
     * const count = await prisma.instructorSlot.count({
     *   where: {
     *     // ... the filter for the InstructorSlots we want to count
     *   }
     * })
    **/
    count<T extends InstructorSlotCountArgs>(
      args?: Subset<T, InstructorSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstructorSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorSlotAggregateArgs>(args: Subset<T, InstructorSlotAggregateArgs>): Prisma.PrismaPromise<GetInstructorSlotAggregateType<T>>

    /**
     * Group by InstructorSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorSlotGroupByArgs['orderBy'] }
        : { orderBy?: InstructorSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstructorSlot model
   */
  readonly fields: InstructorSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstructorSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends InstructorScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructorScheduleDefaultArgs<ExtArgs>>): Prisma__InstructorScheduleClient<$Result.GetResult<Prisma.$InstructorSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstructorSlot model
   */
  interface InstructorSlotFieldRefs {
    readonly scheduleId: FieldRef<"InstructorSlot", 'Int'>
    readonly weekday: FieldRef<"InstructorSlot", 'Int'>
    readonly startTime: FieldRef<"InstructorSlot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstructorSlot findUnique
   */
  export type InstructorSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSlot to fetch.
     */
    where: InstructorSlotWhereUniqueInput
  }

  /**
   * InstructorSlot findUniqueOrThrow
   */
  export type InstructorSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSlot to fetch.
     */
    where: InstructorSlotWhereUniqueInput
  }

  /**
   * InstructorSlot findFirst
   */
  export type InstructorSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSlot to fetch.
     */
    where?: InstructorSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSlots to fetch.
     */
    orderBy?: InstructorSlotOrderByWithRelationInput | InstructorSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorSlots.
     */
    cursor?: InstructorSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorSlots.
     */
    distinct?: InstructorSlotScalarFieldEnum | InstructorSlotScalarFieldEnum[]
  }

  /**
   * InstructorSlot findFirstOrThrow
   */
  export type InstructorSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSlot to fetch.
     */
    where?: InstructorSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSlots to fetch.
     */
    orderBy?: InstructorSlotOrderByWithRelationInput | InstructorSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorSlots.
     */
    cursor?: InstructorSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorSlots.
     */
    distinct?: InstructorSlotScalarFieldEnum | InstructorSlotScalarFieldEnum[]
  }

  /**
   * InstructorSlot findMany
   */
  export type InstructorSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter, which InstructorSlots to fetch.
     */
    where?: InstructorSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorSlots to fetch.
     */
    orderBy?: InstructorSlotOrderByWithRelationInput | InstructorSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstructorSlots.
     */
    cursor?: InstructorSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorSlots.
     */
    skip?: number
    distinct?: InstructorSlotScalarFieldEnum | InstructorSlotScalarFieldEnum[]
  }

  /**
   * InstructorSlot create
   */
  export type InstructorSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a InstructorSlot.
     */
    data: XOR<InstructorSlotCreateInput, InstructorSlotUncheckedCreateInput>
  }

  /**
   * InstructorSlot createMany
   */
  export type InstructorSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstructorSlots.
     */
    data: InstructorSlotCreateManyInput | InstructorSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstructorSlot createManyAndReturn
   */
  export type InstructorSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * The data used to create many InstructorSlots.
     */
    data: InstructorSlotCreateManyInput | InstructorSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorSlot update
   */
  export type InstructorSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a InstructorSlot.
     */
    data: XOR<InstructorSlotUpdateInput, InstructorSlotUncheckedUpdateInput>
    /**
     * Choose, which InstructorSlot to update.
     */
    where: InstructorSlotWhereUniqueInput
  }

  /**
   * InstructorSlot updateMany
   */
  export type InstructorSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstructorSlots.
     */
    data: XOR<InstructorSlotUpdateManyMutationInput, InstructorSlotUncheckedUpdateManyInput>
    /**
     * Filter which InstructorSlots to update
     */
    where?: InstructorSlotWhereInput
    /**
     * Limit how many InstructorSlots to update.
     */
    limit?: number
  }

  /**
   * InstructorSlot updateManyAndReturn
   */
  export type InstructorSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * The data used to update InstructorSlots.
     */
    data: XOR<InstructorSlotUpdateManyMutationInput, InstructorSlotUncheckedUpdateManyInput>
    /**
     * Filter which InstructorSlots to update
     */
    where?: InstructorSlotWhereInput
    /**
     * Limit how many InstructorSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorSlot upsert
   */
  export type InstructorSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the InstructorSlot to update in case it exists.
     */
    where: InstructorSlotWhereUniqueInput
    /**
     * In case the InstructorSlot found by the `where` argument doesn't exist, create a new InstructorSlot with this data.
     */
    create: XOR<InstructorSlotCreateInput, InstructorSlotUncheckedCreateInput>
    /**
     * In case the InstructorSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorSlotUpdateInput, InstructorSlotUncheckedUpdateInput>
  }

  /**
   * InstructorSlot delete
   */
  export type InstructorSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
    /**
     * Filter which InstructorSlot to delete.
     */
    where: InstructorSlotWhereUniqueInput
  }

  /**
   * InstructorSlot deleteMany
   */
  export type InstructorSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorSlots to delete
     */
    where?: InstructorSlotWhereInput
    /**
     * Limit how many InstructorSlots to delete.
     */
    limit?: number
  }

  /**
   * InstructorSlot without action
   */
  export type InstructorSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorSlot
     */
    select?: InstructorSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorSlot
     */
    omit?: InstructorSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorSlotInclude<ExtArgs> | null
  }


  /**
   * Model InstructorAbsence
   */

  export type AggregateInstructorAbsence = {
    _count: InstructorAbsenceCountAggregateOutputType | null
    _avg: InstructorAbsenceAvgAggregateOutputType | null
    _sum: InstructorAbsenceSumAggregateOutputType | null
    _min: InstructorAbsenceMinAggregateOutputType | null
    _max: InstructorAbsenceMaxAggregateOutputType | null
  }

  export type InstructorAbsenceAvgAggregateOutputType = {
    instructorId: number | null
  }

  export type InstructorAbsenceSumAggregateOutputType = {
    instructorId: number | null
  }

  export type InstructorAbsenceMinAggregateOutputType = {
    instructorId: number | null
    absentAt: Date | null
  }

  export type InstructorAbsenceMaxAggregateOutputType = {
    instructorId: number | null
    absentAt: Date | null
  }

  export type InstructorAbsenceCountAggregateOutputType = {
    instructorId: number
    absentAt: number
    _all: number
  }


  export type InstructorAbsenceAvgAggregateInputType = {
    instructorId?: true
  }

  export type InstructorAbsenceSumAggregateInputType = {
    instructorId?: true
  }

  export type InstructorAbsenceMinAggregateInputType = {
    instructorId?: true
    absentAt?: true
  }

  export type InstructorAbsenceMaxAggregateInputType = {
    instructorId?: true
    absentAt?: true
  }

  export type InstructorAbsenceCountAggregateInputType = {
    instructorId?: true
    absentAt?: true
    _all?: true
  }

  export type InstructorAbsenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorAbsence to aggregate.
     */
    where?: InstructorAbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorAbsences to fetch.
     */
    orderBy?: InstructorAbsenceOrderByWithRelationInput | InstructorAbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructorAbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorAbsences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorAbsences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstructorAbsences
    **/
    _count?: true | InstructorAbsenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructorAbsenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructorAbsenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructorAbsenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructorAbsenceMaxAggregateInputType
  }

  export type GetInstructorAbsenceAggregateType<T extends InstructorAbsenceAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructorAbsence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructorAbsence[P]>
      : GetScalarType<T[P], AggregateInstructorAbsence[P]>
  }




  export type InstructorAbsenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructorAbsenceWhereInput
    orderBy?: InstructorAbsenceOrderByWithAggregationInput | InstructorAbsenceOrderByWithAggregationInput[]
    by: InstructorAbsenceScalarFieldEnum[] | InstructorAbsenceScalarFieldEnum
    having?: InstructorAbsenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructorAbsenceCountAggregateInputType | true
    _avg?: InstructorAbsenceAvgAggregateInputType
    _sum?: InstructorAbsenceSumAggregateInputType
    _min?: InstructorAbsenceMinAggregateInputType
    _max?: InstructorAbsenceMaxAggregateInputType
  }

  export type InstructorAbsenceGroupByOutputType = {
    instructorId: number
    absentAt: Date
    _count: InstructorAbsenceCountAggregateOutputType | null
    _avg: InstructorAbsenceAvgAggregateOutputType | null
    _sum: InstructorAbsenceSumAggregateOutputType | null
    _min: InstructorAbsenceMinAggregateOutputType | null
    _max: InstructorAbsenceMaxAggregateOutputType | null
  }

  type GetInstructorAbsenceGroupByPayload<T extends InstructorAbsenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructorAbsenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructorAbsenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructorAbsenceGroupByOutputType[P]>
            : GetScalarType<T[P], InstructorAbsenceGroupByOutputType[P]>
        }
      >
    >


  export type InstructorAbsenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instructorId?: boolean
    absentAt?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorAbsence"]>

  export type InstructorAbsenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instructorId?: boolean
    absentAt?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorAbsence"]>

  export type InstructorAbsenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    instructorId?: boolean
    absentAt?: boolean
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instructorAbsence"]>

  export type InstructorAbsenceSelectScalar = {
    instructorId?: boolean
    absentAt?: boolean
  }

  export type InstructorAbsenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"instructorId" | "absentAt", ExtArgs["result"]["instructorAbsence"]>
  export type InstructorAbsenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }
  export type InstructorAbsenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }
  export type InstructorAbsenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | InstructorDefaultArgs<ExtArgs>
  }

  export type $InstructorAbsencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstructorAbsence"
    objects: {
      instructor: Prisma.$InstructorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      instructorId: number
      absentAt: Date
    }, ExtArgs["result"]["instructorAbsence"]>
    composites: {}
  }

  type InstructorAbsenceGetPayload<S extends boolean | null | undefined | InstructorAbsenceDefaultArgs> = $Result.GetResult<Prisma.$InstructorAbsencePayload, S>

  type InstructorAbsenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstructorAbsenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstructorAbsenceCountAggregateInputType | true
    }

  export interface InstructorAbsenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstructorAbsence'], meta: { name: 'InstructorAbsence' } }
    /**
     * Find zero or one InstructorAbsence that matches the filter.
     * @param {InstructorAbsenceFindUniqueArgs} args - Arguments to find a InstructorAbsence
     * @example
     * // Get one InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstructorAbsenceFindUniqueArgs>(args: SelectSubset<T, InstructorAbsenceFindUniqueArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstructorAbsence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstructorAbsenceFindUniqueOrThrowArgs} args - Arguments to find a InstructorAbsence
     * @example
     * // Get one InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstructorAbsenceFindUniqueOrThrowArgs>(args: SelectSubset<T, InstructorAbsenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorAbsence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceFindFirstArgs} args - Arguments to find a InstructorAbsence
     * @example
     * // Get one InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstructorAbsenceFindFirstArgs>(args?: SelectSubset<T, InstructorAbsenceFindFirstArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstructorAbsence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceFindFirstOrThrowArgs} args - Arguments to find a InstructorAbsence
     * @example
     * // Get one InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstructorAbsenceFindFirstOrThrowArgs>(args?: SelectSubset<T, InstructorAbsenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstructorAbsences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstructorAbsences
     * const instructorAbsences = await prisma.instructorAbsence.findMany()
     * 
     * // Get first 10 InstructorAbsences
     * const instructorAbsences = await prisma.instructorAbsence.findMany({ take: 10 })
     * 
     * // Only select the `instructorId`
     * const instructorAbsenceWithInstructorIdOnly = await prisma.instructorAbsence.findMany({ select: { instructorId: true } })
     * 
     */
    findMany<T extends InstructorAbsenceFindManyArgs>(args?: SelectSubset<T, InstructorAbsenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstructorAbsence.
     * @param {InstructorAbsenceCreateArgs} args - Arguments to create a InstructorAbsence.
     * @example
     * // Create one InstructorAbsence
     * const InstructorAbsence = await prisma.instructorAbsence.create({
     *   data: {
     *     // ... data to create a InstructorAbsence
     *   }
     * })
     * 
     */
    create<T extends InstructorAbsenceCreateArgs>(args: SelectSubset<T, InstructorAbsenceCreateArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstructorAbsences.
     * @param {InstructorAbsenceCreateManyArgs} args - Arguments to create many InstructorAbsences.
     * @example
     * // Create many InstructorAbsences
     * const instructorAbsence = await prisma.instructorAbsence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstructorAbsenceCreateManyArgs>(args?: SelectSubset<T, InstructorAbsenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstructorAbsences and returns the data saved in the database.
     * @param {InstructorAbsenceCreateManyAndReturnArgs} args - Arguments to create many InstructorAbsences.
     * @example
     * // Create many InstructorAbsences
     * const instructorAbsence = await prisma.instructorAbsence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstructorAbsences and only return the `instructorId`
     * const instructorAbsenceWithInstructorIdOnly = await prisma.instructorAbsence.createManyAndReturn({
     *   select: { instructorId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstructorAbsenceCreateManyAndReturnArgs>(args?: SelectSubset<T, InstructorAbsenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstructorAbsence.
     * @param {InstructorAbsenceDeleteArgs} args - Arguments to delete one InstructorAbsence.
     * @example
     * // Delete one InstructorAbsence
     * const InstructorAbsence = await prisma.instructorAbsence.delete({
     *   where: {
     *     // ... filter to delete one InstructorAbsence
     *   }
     * })
     * 
     */
    delete<T extends InstructorAbsenceDeleteArgs>(args: SelectSubset<T, InstructorAbsenceDeleteArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstructorAbsence.
     * @param {InstructorAbsenceUpdateArgs} args - Arguments to update one InstructorAbsence.
     * @example
     * // Update one InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstructorAbsenceUpdateArgs>(args: SelectSubset<T, InstructorAbsenceUpdateArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstructorAbsences.
     * @param {InstructorAbsenceDeleteManyArgs} args - Arguments to filter InstructorAbsences to delete.
     * @example
     * // Delete a few InstructorAbsences
     * const { count } = await prisma.instructorAbsence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstructorAbsenceDeleteManyArgs>(args?: SelectSubset<T, InstructorAbsenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorAbsences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstructorAbsences
     * const instructorAbsence = await prisma.instructorAbsence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstructorAbsenceUpdateManyArgs>(args: SelectSubset<T, InstructorAbsenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructorAbsences and returns the data updated in the database.
     * @param {InstructorAbsenceUpdateManyAndReturnArgs} args - Arguments to update many InstructorAbsences.
     * @example
     * // Update many InstructorAbsences
     * const instructorAbsence = await prisma.instructorAbsence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstructorAbsences and only return the `instructorId`
     * const instructorAbsenceWithInstructorIdOnly = await prisma.instructorAbsence.updateManyAndReturn({
     *   select: { instructorId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstructorAbsenceUpdateManyAndReturnArgs>(args: SelectSubset<T, InstructorAbsenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstructorAbsence.
     * @param {InstructorAbsenceUpsertArgs} args - Arguments to update or create a InstructorAbsence.
     * @example
     * // Update or create a InstructorAbsence
     * const instructorAbsence = await prisma.instructorAbsence.upsert({
     *   create: {
     *     // ... data to create a InstructorAbsence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstructorAbsence we want to update
     *   }
     * })
     */
    upsert<T extends InstructorAbsenceUpsertArgs>(args: SelectSubset<T, InstructorAbsenceUpsertArgs<ExtArgs>>): Prisma__InstructorAbsenceClient<$Result.GetResult<Prisma.$InstructorAbsencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstructorAbsences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceCountArgs} args - Arguments to filter InstructorAbsences to count.
     * @example
     * // Count the number of InstructorAbsences
     * const count = await prisma.instructorAbsence.count({
     *   where: {
     *     // ... the filter for the InstructorAbsences we want to count
     *   }
     * })
    **/
    count<T extends InstructorAbsenceCountArgs>(
      args?: Subset<T, InstructorAbsenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructorAbsenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstructorAbsence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructorAbsenceAggregateArgs>(args: Subset<T, InstructorAbsenceAggregateArgs>): Prisma.PrismaPromise<GetInstructorAbsenceAggregateType<T>>

    /**
     * Group by InstructorAbsence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructorAbsenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructorAbsenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructorAbsenceGroupByArgs['orderBy'] }
        : { orderBy?: InstructorAbsenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructorAbsenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructorAbsenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstructorAbsence model
   */
  readonly fields: InstructorAbsenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstructorAbsence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructorAbsenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instructor<T extends InstructorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructorDefaultArgs<ExtArgs>>): Prisma__InstructorClient<$Result.GetResult<Prisma.$InstructorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstructorAbsence model
   */
  interface InstructorAbsenceFieldRefs {
    readonly instructorId: FieldRef<"InstructorAbsence", 'Int'>
    readonly absentAt: FieldRef<"InstructorAbsence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstructorAbsence findUnique
   */
  export type InstructorAbsenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter, which InstructorAbsence to fetch.
     */
    where: InstructorAbsenceWhereUniqueInput
  }

  /**
   * InstructorAbsence findUniqueOrThrow
   */
  export type InstructorAbsenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter, which InstructorAbsence to fetch.
     */
    where: InstructorAbsenceWhereUniqueInput
  }

  /**
   * InstructorAbsence findFirst
   */
  export type InstructorAbsenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter, which InstructorAbsence to fetch.
     */
    where?: InstructorAbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorAbsences to fetch.
     */
    orderBy?: InstructorAbsenceOrderByWithRelationInput | InstructorAbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorAbsences.
     */
    cursor?: InstructorAbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorAbsences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorAbsences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorAbsences.
     */
    distinct?: InstructorAbsenceScalarFieldEnum | InstructorAbsenceScalarFieldEnum[]
  }

  /**
   * InstructorAbsence findFirstOrThrow
   */
  export type InstructorAbsenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter, which InstructorAbsence to fetch.
     */
    where?: InstructorAbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorAbsences to fetch.
     */
    orderBy?: InstructorAbsenceOrderByWithRelationInput | InstructorAbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructorAbsences.
     */
    cursor?: InstructorAbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorAbsences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorAbsences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructorAbsences.
     */
    distinct?: InstructorAbsenceScalarFieldEnum | InstructorAbsenceScalarFieldEnum[]
  }

  /**
   * InstructorAbsence findMany
   */
  export type InstructorAbsenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter, which InstructorAbsences to fetch.
     */
    where?: InstructorAbsenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructorAbsences to fetch.
     */
    orderBy?: InstructorAbsenceOrderByWithRelationInput | InstructorAbsenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstructorAbsences.
     */
    cursor?: InstructorAbsenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructorAbsences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructorAbsences.
     */
    skip?: number
    distinct?: InstructorAbsenceScalarFieldEnum | InstructorAbsenceScalarFieldEnum[]
  }

  /**
   * InstructorAbsence create
   */
  export type InstructorAbsenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * The data needed to create a InstructorAbsence.
     */
    data: XOR<InstructorAbsenceCreateInput, InstructorAbsenceUncheckedCreateInput>
  }

  /**
   * InstructorAbsence createMany
   */
  export type InstructorAbsenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstructorAbsences.
     */
    data: InstructorAbsenceCreateManyInput | InstructorAbsenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstructorAbsence createManyAndReturn
   */
  export type InstructorAbsenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * The data used to create many InstructorAbsences.
     */
    data: InstructorAbsenceCreateManyInput | InstructorAbsenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorAbsence update
   */
  export type InstructorAbsenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * The data needed to update a InstructorAbsence.
     */
    data: XOR<InstructorAbsenceUpdateInput, InstructorAbsenceUncheckedUpdateInput>
    /**
     * Choose, which InstructorAbsence to update.
     */
    where: InstructorAbsenceWhereUniqueInput
  }

  /**
   * InstructorAbsence updateMany
   */
  export type InstructorAbsenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstructorAbsences.
     */
    data: XOR<InstructorAbsenceUpdateManyMutationInput, InstructorAbsenceUncheckedUpdateManyInput>
    /**
     * Filter which InstructorAbsences to update
     */
    where?: InstructorAbsenceWhereInput
    /**
     * Limit how many InstructorAbsences to update.
     */
    limit?: number
  }

  /**
   * InstructorAbsence updateManyAndReturn
   */
  export type InstructorAbsenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * The data used to update InstructorAbsences.
     */
    data: XOR<InstructorAbsenceUpdateManyMutationInput, InstructorAbsenceUncheckedUpdateManyInput>
    /**
     * Filter which InstructorAbsences to update
     */
    where?: InstructorAbsenceWhereInput
    /**
     * Limit how many InstructorAbsences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstructorAbsence upsert
   */
  export type InstructorAbsenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * The filter to search for the InstructorAbsence to update in case it exists.
     */
    where: InstructorAbsenceWhereUniqueInput
    /**
     * In case the InstructorAbsence found by the `where` argument doesn't exist, create a new InstructorAbsence with this data.
     */
    create: XOR<InstructorAbsenceCreateInput, InstructorAbsenceUncheckedCreateInput>
    /**
     * In case the InstructorAbsence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructorAbsenceUpdateInput, InstructorAbsenceUncheckedUpdateInput>
  }

  /**
   * InstructorAbsence delete
   */
  export type InstructorAbsenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
    /**
     * Filter which InstructorAbsence to delete.
     */
    where: InstructorAbsenceWhereUniqueInput
  }

  /**
   * InstructorAbsence deleteMany
   */
  export type InstructorAbsenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructorAbsences to delete
     */
    where?: InstructorAbsenceWhereInput
    /**
     * Limit how many InstructorAbsences to delete.
     */
    limit?: number
  }

  /**
   * InstructorAbsence without action
   */
  export type InstructorAbsenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructorAbsence
     */
    select?: InstructorAbsenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstructorAbsence
     */
    omit?: InstructorAbsenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstructorAbsenceInclude<ExtArgs> | null
  }


  /**
   * Model SystemStatus
   */

  export type AggregateSystemStatus = {
    _count: SystemStatusCountAggregateOutputType | null
    _avg: SystemStatusAvgAggregateOutputType | null
    _sum: SystemStatusSumAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  export type SystemStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type SystemStatusSumAggregateOutputType = {
    id: number | null
  }

  export type SystemStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemStatusCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemStatusAvgAggregateInputType = {
    id?: true
  }

  export type SystemStatusSumAggregateInputType = {
    id?: true
  }

  export type SystemStatusMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemStatusMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemStatusCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatus to aggregate.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemStatuses
    **/
    _count?: true | SystemStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemStatusMaxAggregateInputType
  }

  export type GetSystemStatusAggregateType<T extends SystemStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemStatus[P]>
      : GetScalarType<T[P], AggregateSystemStatus[P]>
  }




  export type SystemStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemStatusWhereInput
    orderBy?: SystemStatusOrderByWithAggregationInput | SystemStatusOrderByWithAggregationInput[]
    by: SystemStatusScalarFieldEnum[] | SystemStatusScalarFieldEnum
    having?: SystemStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemStatusCountAggregateInputType | true
    _avg?: SystemStatusAvgAggregateInputType
    _sum?: SystemStatusSumAggregateInputType
    _min?: SystemStatusMinAggregateInputType
    _max?: SystemStatusMaxAggregateInputType
  }

  export type SystemStatusGroupByOutputType = {
    id: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SystemStatusCountAggregateOutputType | null
    _avg: SystemStatusAvgAggregateOutputType | null
    _sum: SystemStatusSumAggregateOutputType | null
    _min: SystemStatusMinAggregateOutputType | null
    _max: SystemStatusMaxAggregateOutputType | null
  }

  type GetSystemStatusGroupByPayload<T extends SystemStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SystemStatusGroupByOutputType[P]>
        }
      >
    >


  export type SystemStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemStatus"]>

  export type SystemStatusSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["systemStatus"]>

  export type $SystemStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemStatus"]>
    composites: {}
  }

  type SystemStatusGetPayload<S extends boolean | null | undefined | SystemStatusDefaultArgs> = $Result.GetResult<Prisma.$SystemStatusPayload, S>

  type SystemStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemStatusCountAggregateInputType | true
    }

  export interface SystemStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemStatus'], meta: { name: 'SystemStatus' } }
    /**
     * Find zero or one SystemStatus that matches the filter.
     * @param {SystemStatusFindUniqueArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemStatusFindUniqueArgs>(args: SelectSubset<T, SystemStatusFindUniqueArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemStatusFindUniqueOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemStatusFindFirstArgs>(args?: SelectSubset<T, SystemStatusFindFirstArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindFirstOrThrowArgs} args - Arguments to find a SystemStatus
     * @example
     * // Get one SystemStatus
     * const systemStatus = await prisma.systemStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany()
     * 
     * // Get first 10 SystemStatuses
     * const systemStatuses = await prisma.systemStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemStatusWithIdOnly = await prisma.systemStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemStatusFindManyArgs>(args?: SelectSubset<T, SystemStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemStatus.
     * @param {SystemStatusCreateArgs} args - Arguments to create a SystemStatus.
     * @example
     * // Create one SystemStatus
     * const SystemStatus = await prisma.systemStatus.create({
     *   data: {
     *     // ... data to create a SystemStatus
     *   }
     * })
     * 
     */
    create<T extends SystemStatusCreateArgs>(args: SelectSubset<T, SystemStatusCreateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemStatuses.
     * @param {SystemStatusCreateManyArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemStatusCreateManyArgs>(args?: SelectSubset<T, SystemStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemStatuses and returns the data saved in the database.
     * @param {SystemStatusCreateManyAndReturnArgs} args - Arguments to create many SystemStatuses.
     * @example
     * // Create many SystemStatuses
     * const systemStatus = await prisma.systemStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemStatuses and only return the `id`
     * const systemStatusWithIdOnly = await prisma.systemStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemStatus.
     * @param {SystemStatusDeleteArgs} args - Arguments to delete one SystemStatus.
     * @example
     * // Delete one SystemStatus
     * const SystemStatus = await prisma.systemStatus.delete({
     *   where: {
     *     // ... filter to delete one SystemStatus
     *   }
     * })
     * 
     */
    delete<T extends SystemStatusDeleteArgs>(args: SelectSubset<T, SystemStatusDeleteArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemStatus.
     * @param {SystemStatusUpdateArgs} args - Arguments to update one SystemStatus.
     * @example
     * // Update one SystemStatus
     * const systemStatus = await prisma.systemStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemStatusUpdateArgs>(args: SelectSubset<T, SystemStatusUpdateArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemStatuses.
     * @param {SystemStatusDeleteManyArgs} args - Arguments to filter SystemStatuses to delete.
     * @example
     * // Delete a few SystemStatuses
     * const { count } = await prisma.systemStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemStatusDeleteManyArgs>(args?: SelectSubset<T, SystemStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemStatuses
     * const systemStatus = await prisma.systemStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemStatusUpdateManyArgs>(args: SelectSubset<T, SystemStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemStatuses and returns the data updated in the database.
     * @param {SystemStatusUpdateManyAndReturnArgs} args - Arguments to update many SystemStatuses.
     * @example
     * // Update many SystemStatuses
     * const systemStatus = await prisma.systemStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemStatuses and only return the `id`
     * const systemStatusWithIdOnly = await prisma.systemStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemStatus.
     * @param {SystemStatusUpsertArgs} args - Arguments to update or create a SystemStatus.
     * @example
     * // Update or create a SystemStatus
     * const systemStatus = await prisma.systemStatus.upsert({
     *   create: {
     *     // ... data to create a SystemStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemStatus we want to update
     *   }
     * })
     */
    upsert<T extends SystemStatusUpsertArgs>(args: SelectSubset<T, SystemStatusUpsertArgs<ExtArgs>>): Prisma__SystemStatusClient<$Result.GetResult<Prisma.$SystemStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusCountArgs} args - Arguments to filter SystemStatuses to count.
     * @example
     * // Count the number of SystemStatuses
     * const count = await prisma.systemStatus.count({
     *   where: {
     *     // ... the filter for the SystemStatuses we want to count
     *   }
     * })
    **/
    count<T extends SystemStatusCountArgs>(
      args?: Subset<T, SystemStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemStatusAggregateArgs>(args: Subset<T, SystemStatusAggregateArgs>): Prisma.PrismaPromise<GetSystemStatusAggregateType<T>>

    /**
     * Group by SystemStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemStatusGroupByArgs['orderBy'] }
        : { orderBy?: SystemStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemStatus model
   */
  readonly fields: SystemStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemStatus model
   */
  interface SystemStatusFieldRefs {
    readonly id: FieldRef<"SystemStatus", 'Int'>
    readonly status: FieldRef<"SystemStatus", 'String'>
    readonly createdAt: FieldRef<"SystemStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemStatus findUnique
   */
  export type SystemStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findUniqueOrThrow
   */
  export type SystemStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus findFirst
   */
  export type SystemStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findFirstOrThrow
   */
  export type SystemStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter, which SystemStatus to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemStatuses.
     */
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus findMany
   */
  export type SystemStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter, which SystemStatuses to fetch.
     */
    where?: SystemStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemStatuses to fetch.
     */
    orderBy?: SystemStatusOrderByWithRelationInput | SystemStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemStatuses.
     */
    cursor?: SystemStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemStatuses.
     */
    skip?: number
    distinct?: SystemStatusScalarFieldEnum | SystemStatusScalarFieldEnum[]
  }

  /**
   * SystemStatus create
   */
  export type SystemStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemStatus.
     */
    data: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
  }

  /**
   * SystemStatus createMany
   */
  export type SystemStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemStatus createManyAndReturn
   */
  export type SystemStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * The data used to create many SystemStatuses.
     */
    data: SystemStatusCreateManyInput | SystemStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemStatus update
   */
  export type SystemStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemStatus.
     */
    data: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
    /**
     * Choose, which SystemStatus to update.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus updateMany
   */
  export type SystemStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemStatuses.
     */
    data: XOR<SystemStatusUpdateManyMutationInput, SystemStatusUncheckedUpdateManyInput>
    /**
     * Filter which SystemStatuses to update
     */
    where?: SystemStatusWhereInput
    /**
     * Limit how many SystemStatuses to update.
     */
    limit?: number
  }

  /**
   * SystemStatus updateManyAndReturn
   */
  export type SystemStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * The data used to update SystemStatuses.
     */
    data: XOR<SystemStatusUpdateManyMutationInput, SystemStatusUncheckedUpdateManyInput>
    /**
     * Filter which SystemStatuses to update
     */
    where?: SystemStatusWhereInput
    /**
     * Limit how many SystemStatuses to update.
     */
    limit?: number
  }

  /**
   * SystemStatus upsert
   */
  export type SystemStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemStatus to update in case it exists.
     */
    where: SystemStatusWhereUniqueInput
    /**
     * In case the SystemStatus found by the `where` argument doesn't exist, create a new SystemStatus with this data.
     */
    create: XOR<SystemStatusCreateInput, SystemStatusUncheckedCreateInput>
    /**
     * In case the SystemStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemStatusUpdateInput, SystemStatusUncheckedUpdateInput>
  }

  /**
   * SystemStatus delete
   */
  export type SystemStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
    /**
     * Filter which SystemStatus to delete.
     */
    where: SystemStatusWhereUniqueInput
  }

  /**
   * SystemStatus deleteMany
   */
  export type SystemStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemStatuses to delete
     */
    where?: SystemStatusWhereInput
    /**
     * Limit how many SystemStatuses to delete.
     */
    limit?: number
  }

  /**
   * SystemStatus without action
   */
  export type SystemStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemStatus
     */
    select?: SystemStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemStatus
     */
    omit?: SystemStatusOmit<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
  }


  /**
   * Model Child
   */

  export type AggregateChild = {
    _count: ChildCountAggregateOutputType | null
    _avg: ChildAvgAggregateOutputType | null
    _sum: ChildSumAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  export type ChildAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type ChildSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type ChildMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    name: string | null
    birthdate: Date | null
    personalInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    name: string | null
    birthdate: Date | null
    personalInfo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChildCountAggregateOutputType = {
    id: number
    customerId: number
    name: number
    birthdate: number
    personalInfo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChildAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type ChildSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type ChildMinAggregateInputType = {
    id?: true
    customerId?: true
    name?: true
    birthdate?: true
    personalInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildMaxAggregateInputType = {
    id?: true
    customerId?: true
    name?: true
    birthdate?: true
    personalInfo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChildCountAggregateInputType = {
    id?: true
    customerId?: true
    name?: true
    birthdate?: true
    personalInfo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChildAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Child to aggregate.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Children
    **/
    _count?: true | ChildCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChildAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChildSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChildMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChildMaxAggregateInputType
  }

  export type GetChildAggregateType<T extends ChildAggregateArgs> = {
        [P in keyof T & keyof AggregateChild]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChild[P]>
      : GetScalarType<T[P], AggregateChild[P]>
  }




  export type ChildGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChildWhereInput
    orderBy?: ChildOrderByWithAggregationInput | ChildOrderByWithAggregationInput[]
    by: ChildScalarFieldEnum[] | ChildScalarFieldEnum
    having?: ChildScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChildCountAggregateInputType | true
    _avg?: ChildAvgAggregateInputType
    _sum?: ChildSumAggregateInputType
    _min?: ChildMinAggregateInputType
    _max?: ChildMaxAggregateInputType
  }

  export type ChildGroupByOutputType = {
    id: number
    customerId: number
    name: string
    birthdate: Date | null
    personalInfo: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChildCountAggregateOutputType | null
    _avg: ChildAvgAggregateOutputType | null
    _sum: ChildSumAggregateOutputType | null
    _min: ChildMinAggregateOutputType | null
    _max: ChildMaxAggregateOutputType | null
  }

  type GetChildGroupByPayload<T extends ChildGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChildGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChildGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChildGroupByOutputType[P]>
            : GetScalarType<T[P], ChildGroupByOutputType[P]>
        }
      >
    >


  export type ChildSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    name?: boolean
    birthdate?: boolean
    personalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    classAttendance?: boolean | Child$classAttendanceArgs<ExtArgs>
    recurringClassAttendance?: boolean | Child$recurringClassAttendanceArgs<ExtArgs>
    _count?: boolean | ChildCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    name?: boolean
    birthdate?: boolean
    personalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    name?: boolean
    birthdate?: boolean
    personalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["child"]>

  export type ChildSelectScalar = {
    id?: boolean
    customerId?: boolean
    name?: boolean
    birthdate?: boolean
    personalInfo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChildOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "name" | "birthdate" | "personalInfo" | "createdAt" | "updatedAt", ExtArgs["result"]["child"]>
  export type ChildInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    classAttendance?: boolean | Child$classAttendanceArgs<ExtArgs>
    recurringClassAttendance?: boolean | Child$recurringClassAttendanceArgs<ExtArgs>
    _count?: boolean | ChildCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChildIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type ChildIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $ChildPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Child"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      classAttendance: Prisma.$ClassAttendancePayload<ExtArgs>[]
      recurringClassAttendance: Prisma.$RecurringClassAttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      name: string
      birthdate: Date | null
      personalInfo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["child"]>
    composites: {}
  }

  type ChildGetPayload<S extends boolean | null | undefined | ChildDefaultArgs> = $Result.GetResult<Prisma.$ChildPayload, S>

  type ChildCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChildFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChildCountAggregateInputType | true
    }

  export interface ChildDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Child'], meta: { name: 'Child' } }
    /**
     * Find zero or one Child that matches the filter.
     * @param {ChildFindUniqueArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChildFindUniqueArgs>(args: SelectSubset<T, ChildFindUniqueArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Child that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChildFindUniqueOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChildFindUniqueOrThrowArgs>(args: SelectSubset<T, ChildFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Child that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChildFindFirstArgs>(args?: SelectSubset<T, ChildFindFirstArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Child that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindFirstOrThrowArgs} args - Arguments to find a Child
     * @example
     * // Get one Child
     * const child = await prisma.child.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChildFindFirstOrThrowArgs>(args?: SelectSubset<T, ChildFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Children that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Children
     * const children = await prisma.child.findMany()
     * 
     * // Get first 10 Children
     * const children = await prisma.child.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const childWithIdOnly = await prisma.child.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChildFindManyArgs>(args?: SelectSubset<T, ChildFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Child.
     * @param {ChildCreateArgs} args - Arguments to create a Child.
     * @example
     * // Create one Child
     * const Child = await prisma.child.create({
     *   data: {
     *     // ... data to create a Child
     *   }
     * })
     * 
     */
    create<T extends ChildCreateArgs>(args: SelectSubset<T, ChildCreateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Children.
     * @param {ChildCreateManyArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChildCreateManyArgs>(args?: SelectSubset<T, ChildCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Children and returns the data saved in the database.
     * @param {ChildCreateManyAndReturnArgs} args - Arguments to create many Children.
     * @example
     * // Create many Children
     * const child = await prisma.child.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Children and only return the `id`
     * const childWithIdOnly = await prisma.child.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChildCreateManyAndReturnArgs>(args?: SelectSubset<T, ChildCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Child.
     * @param {ChildDeleteArgs} args - Arguments to delete one Child.
     * @example
     * // Delete one Child
     * const Child = await prisma.child.delete({
     *   where: {
     *     // ... filter to delete one Child
     *   }
     * })
     * 
     */
    delete<T extends ChildDeleteArgs>(args: SelectSubset<T, ChildDeleteArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Child.
     * @param {ChildUpdateArgs} args - Arguments to update one Child.
     * @example
     * // Update one Child
     * const child = await prisma.child.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChildUpdateArgs>(args: SelectSubset<T, ChildUpdateArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Children.
     * @param {ChildDeleteManyArgs} args - Arguments to filter Children to delete.
     * @example
     * // Delete a few Children
     * const { count } = await prisma.child.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChildDeleteManyArgs>(args?: SelectSubset<T, ChildDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChildUpdateManyArgs>(args: SelectSubset<T, ChildUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Children and returns the data updated in the database.
     * @param {ChildUpdateManyAndReturnArgs} args - Arguments to update many Children.
     * @example
     * // Update many Children
     * const child = await prisma.child.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Children and only return the `id`
     * const childWithIdOnly = await prisma.child.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChildUpdateManyAndReturnArgs>(args: SelectSubset<T, ChildUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Child.
     * @param {ChildUpsertArgs} args - Arguments to update or create a Child.
     * @example
     * // Update or create a Child
     * const child = await prisma.child.upsert({
     *   create: {
     *     // ... data to create a Child
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Child we want to update
     *   }
     * })
     */
    upsert<T extends ChildUpsertArgs>(args: SelectSubset<T, ChildUpsertArgs<ExtArgs>>): Prisma__ChildClient<$Result.GetResult<Prisma.$ChildPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Children.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildCountArgs} args - Arguments to filter Children to count.
     * @example
     * // Count the number of Children
     * const count = await prisma.child.count({
     *   where: {
     *     // ... the filter for the Children we want to count
     *   }
     * })
    **/
    count<T extends ChildCountArgs>(
      args?: Subset<T, ChildCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChildCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChildAggregateArgs>(args: Subset<T, ChildAggregateArgs>): Prisma.PrismaPromise<GetChildAggregateType<T>>

    /**
     * Group by Child.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChildGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChildGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChildGroupByArgs['orderBy'] }
        : { orderBy?: ChildGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChildGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChildGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Child model
   */
  readonly fields: ChildFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Child.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChildClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classAttendance<T extends Child$classAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Child$classAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringClassAttendance<T extends Child$recurringClassAttendanceArgs<ExtArgs> = {}>(args?: Subset<T, Child$recurringClassAttendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecurringClassAttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Child model
   */
  interface ChildFieldRefs {
    readonly id: FieldRef<"Child", 'Int'>
    readonly customerId: FieldRef<"Child", 'Int'>
    readonly name: FieldRef<"Child", 'String'>
    readonly birthdate: FieldRef<"Child", 'DateTime'>
    readonly personalInfo: FieldRef<"Child", 'String'>
    readonly createdAt: FieldRef<"Child", 'DateTime'>
    readonly updatedAt: FieldRef<"Child", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Child findUnique
   */
  export type ChildFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findUniqueOrThrow
   */
  export type ChildFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child findFirst
   */
  export type ChildFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findFirstOrThrow
   */
  export type ChildFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Child to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Children.
     */
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child findMany
   */
  export type ChildFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter, which Children to fetch.
     */
    where?: ChildWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Children to fetch.
     */
    orderBy?: ChildOrderByWithRelationInput | ChildOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Children.
     */
    cursor?: ChildWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Children from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Children.
     */
    skip?: number
    distinct?: ChildScalarFieldEnum | ChildScalarFieldEnum[]
  }

  /**
   * Child create
   */
  export type ChildCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to create a Child.
     */
    data: XOR<ChildCreateInput, ChildUncheckedCreateInput>
  }

  /**
   * Child createMany
   */
  export type ChildCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Child createManyAndReturn
   */
  export type ChildCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * The data used to create many Children.
     */
    data: ChildCreateManyInput | ChildCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child update
   */
  export type ChildUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The data needed to update a Child.
     */
    data: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
    /**
     * Choose, which Child to update.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child updateMany
   */
  export type ChildUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to update.
     */
    limit?: number
  }

  /**
   * Child updateManyAndReturn
   */
  export type ChildUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * The data used to update Children.
     */
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyInput>
    /**
     * Filter which Children to update
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Child upsert
   */
  export type ChildUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * The filter to search for the Child to update in case it exists.
     */
    where: ChildWhereUniqueInput
    /**
     * In case the Child found by the `where` argument doesn't exist, create a new Child with this data.
     */
    create: XOR<ChildCreateInput, ChildUncheckedCreateInput>
    /**
     * In case the Child was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChildUpdateInput, ChildUncheckedUpdateInput>
  }

  /**
   * Child delete
   */
  export type ChildDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
    /**
     * Filter which Child to delete.
     */
    where: ChildWhereUniqueInput
  }

  /**
   * Child deleteMany
   */
  export type ChildDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Children to delete
     */
    where?: ChildWhereInput
    /**
     * Limit how many Children to delete.
     */
    limit?: number
  }

  /**
   * Child.classAttendance
   */
  export type Child$classAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassAttendance
     */
    select?: ClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassAttendance
     */
    omit?: ClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassAttendanceInclude<ExtArgs> | null
    where?: ClassAttendanceWhereInput
    orderBy?: ClassAttendanceOrderByWithRelationInput | ClassAttendanceOrderByWithRelationInput[]
    cursor?: ClassAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassAttendanceScalarFieldEnum | ClassAttendanceScalarFieldEnum[]
  }

  /**
   * Child.recurringClassAttendance
   */
  export type Child$recurringClassAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecurringClassAttendance
     */
    select?: RecurringClassAttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RecurringClassAttendance
     */
    omit?: RecurringClassAttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecurringClassAttendanceInclude<ExtArgs> | null
    where?: RecurringClassAttendanceWhereInput
    orderBy?: RecurringClassAttendanceOrderByWithRelationInput | RecurringClassAttendanceOrderByWithRelationInput[]
    cursor?: RecurringClassAttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecurringClassAttendanceScalarFieldEnum | RecurringClassAttendanceScalarFieldEnum[]
  }

  /**
   * Child without action
   */
  export type ChildDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Child
     */
    select?: ChildSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Child
     */
    omit?: ChildOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChildInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const InstructorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    classURL: 'classURL',
    icon: 'icon',
    nickname: 'nickname',
    meetingId: 'meetingId',
    passcode: 'passcode',
    createdAt: 'createdAt',
    birthdate: 'birthdate',
    favoriteFood: 'favoriteFood',
    hobby: 'hobby',
    lifeHistory: 'lifeHistory',
    messageForChildren: 'messageForChildren',
    skill: 'skill',
    workingTime: 'workingTime',
    terminationAt: 'terminationAt',
    updatedAt: 'updatedAt',
    isNative: 'isNative'
  };

  export type InstructorScalarFieldEnum = (typeof InstructorScalarFieldEnum)[keyof typeof InstructorScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    prefecture: 'prefecture',
    emailVerified: 'emailVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hasSeenWelcome: 'hasSeenWelcome',
    terminationAt: 'terminationAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    instructorId: 'instructorId',
    customerId: 'customerId',
    recurringClassId: 'recurringClassId',
    dateTime: 'dateTime',
    status: 'status',
    subscriptionId: 'subscriptionId',
    rebookableUntil: 'rebookableUntil',
    classCode: 'classCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isFreeTrial: 'isFreeTrial'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const ClassAttendanceScalarFieldEnum: {
    classId: 'classId',
    childrenId: 'childrenId'
  };

  export type ClassAttendanceScalarFieldEnum = (typeof ClassAttendanceScalarFieldEnum)[keyof typeof ClassAttendanceScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    weeklyClassTimes: 'weeklyClassTimes',
    createdAt: 'createdAt',
    terminationAt: 'terminationAt',
    updatedAt: 'updatedAt',
    isNative: 'isNative'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    customerId: 'customerId',
    startAt: 'startAt',
    endAt: 'endAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const RecurringClassScalarFieldEnum: {
    id: 'id',
    instructorId: 'instructorId',
    subscriptionId: 'subscriptionId',
    startAt: 'startAt',
    endAt: 'endAt'
  };

  export type RecurringClassScalarFieldEnum = (typeof RecurringClassScalarFieldEnum)[keyof typeof RecurringClassScalarFieldEnum]


  export const RecurringClassAttendanceScalarFieldEnum: {
    recurringClassId: 'recurringClassId',
    childrenId: 'childrenId'
  };

  export type RecurringClassAttendanceScalarFieldEnum = (typeof RecurringClassAttendanceScalarFieldEnum)[keyof typeof RecurringClassAttendanceScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    date: 'date',
    eventId: 'eventId'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const InstructorScheduleScalarFieldEnum: {
    id: 'id',
    instructorId: 'instructorId',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    timezone: 'timezone'
  };

  export type InstructorScheduleScalarFieldEnum = (typeof InstructorScheduleScalarFieldEnum)[keyof typeof InstructorScheduleScalarFieldEnum]


  export const InstructorSlotScalarFieldEnum: {
    scheduleId: 'scheduleId',
    weekday: 'weekday',
    startTime: 'startTime'
  };

  export type InstructorSlotScalarFieldEnum = (typeof InstructorSlotScalarFieldEnum)[keyof typeof InstructorSlotScalarFieldEnum]


  export const InstructorAbsenceScalarFieldEnum: {
    instructorId: 'instructorId',
    absentAt: 'absentAt'
  };

  export type InstructorAbsenceScalarFieldEnum = (typeof InstructorAbsenceScalarFieldEnum)[keyof typeof InstructorAbsenceScalarFieldEnum]


  export const SystemStatusScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemStatusScalarFieldEnum = (typeof SystemStatusScalarFieldEnum)[keyof typeof SystemStatusScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ChildScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    name: 'name',
    birthdate: 'birthdate',
    personalInfo: 'personalInfo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChildScalarFieldEnum = (typeof ChildScalarFieldEnum)[keyof typeof ChildScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type InstructorWhereInput = {
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    id?: IntFilter<"Instructor"> | number
    name?: StringFilter<"Instructor"> | string
    email?: StringFilter<"Instructor"> | string
    password?: StringFilter<"Instructor"> | string
    classURL?: StringFilter<"Instructor"> | string
    icon?: StringFilter<"Instructor"> | string
    nickname?: StringFilter<"Instructor"> | string
    meetingId?: StringFilter<"Instructor"> | string
    passcode?: StringFilter<"Instructor"> | string
    createdAt?: DateTimeFilter<"Instructor"> | Date | string
    birthdate?: DateTimeFilter<"Instructor"> | Date | string
    favoriteFood?: StringFilter<"Instructor"> | string
    hobby?: StringFilter<"Instructor"> | string
    lifeHistory?: StringFilter<"Instructor"> | string
    messageForChildren?: StringFilter<"Instructor"> | string
    skill?: StringFilter<"Instructor"> | string
    workingTime?: StringFilter<"Instructor"> | string
    terminationAt?: DateTimeNullableFilter<"Instructor"> | Date | string | null
    updatedAt?: DateTimeFilter<"Instructor"> | Date | string
    isNative?: BoolFilter<"Instructor"> | boolean
    classes?: ClassListRelationFilter
    instructorAbsences?: InstructorAbsenceListRelationFilter
    instructorSchedules?: InstructorScheduleListRelationFilter
    recurringClasses?: RecurringClassListRelationFilter
  }

  export type InstructorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    classURL?: SortOrder
    icon?: SortOrder
    nickname?: SortOrder
    meetingId?: SortOrder
    passcode?: SortOrder
    createdAt?: SortOrder
    birthdate?: SortOrder
    favoriteFood?: SortOrder
    hobby?: SortOrder
    lifeHistory?: SortOrder
    messageForChildren?: SortOrder
    skill?: SortOrder
    workingTime?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
    classes?: ClassOrderByRelationAggregateInput
    instructorAbsences?: InstructorAbsenceOrderByRelationAggregateInput
    instructorSchedules?: InstructorScheduleOrderByRelationAggregateInput
    recurringClasses?: RecurringClassOrderByRelationAggregateInput
  }

  export type InstructorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    classURL?: string
    icon?: string
    nickname?: string
    meetingId?: string
    passcode?: string
    AND?: InstructorWhereInput | InstructorWhereInput[]
    OR?: InstructorWhereInput[]
    NOT?: InstructorWhereInput | InstructorWhereInput[]
    name?: StringFilter<"Instructor"> | string
    password?: StringFilter<"Instructor"> | string
    createdAt?: DateTimeFilter<"Instructor"> | Date | string
    birthdate?: DateTimeFilter<"Instructor"> | Date | string
    favoriteFood?: StringFilter<"Instructor"> | string
    hobby?: StringFilter<"Instructor"> | string
    lifeHistory?: StringFilter<"Instructor"> | string
    messageForChildren?: StringFilter<"Instructor"> | string
    skill?: StringFilter<"Instructor"> | string
    workingTime?: StringFilter<"Instructor"> | string
    terminationAt?: DateTimeNullableFilter<"Instructor"> | Date | string | null
    updatedAt?: DateTimeFilter<"Instructor"> | Date | string
    isNative?: BoolFilter<"Instructor"> | boolean
    classes?: ClassListRelationFilter
    instructorAbsences?: InstructorAbsenceListRelationFilter
    instructorSchedules?: InstructorScheduleListRelationFilter
    recurringClasses?: RecurringClassListRelationFilter
  }, "id" | "email" | "classURL" | "icon" | "nickname" | "meetingId" | "passcode">

  export type InstructorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    classURL?: SortOrder
    icon?: SortOrder
    nickname?: SortOrder
    meetingId?: SortOrder
    passcode?: SortOrder
    createdAt?: SortOrder
    birthdate?: SortOrder
    favoriteFood?: SortOrder
    hobby?: SortOrder
    lifeHistory?: SortOrder
    messageForChildren?: SortOrder
    skill?: SortOrder
    workingTime?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
    _count?: InstructorCountOrderByAggregateInput
    _avg?: InstructorAvgOrderByAggregateInput
    _max?: InstructorMaxOrderByAggregateInput
    _min?: InstructorMinOrderByAggregateInput
    _sum?: InstructorSumOrderByAggregateInput
  }

  export type InstructorScalarWhereWithAggregatesInput = {
    AND?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    OR?: InstructorScalarWhereWithAggregatesInput[]
    NOT?: InstructorScalarWhereWithAggregatesInput | InstructorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Instructor"> | number
    name?: StringWithAggregatesFilter<"Instructor"> | string
    email?: StringWithAggregatesFilter<"Instructor"> | string
    password?: StringWithAggregatesFilter<"Instructor"> | string
    classURL?: StringWithAggregatesFilter<"Instructor"> | string
    icon?: StringWithAggregatesFilter<"Instructor"> | string
    nickname?: StringWithAggregatesFilter<"Instructor"> | string
    meetingId?: StringWithAggregatesFilter<"Instructor"> | string
    passcode?: StringWithAggregatesFilter<"Instructor"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instructor"> | Date | string
    birthdate?: DateTimeWithAggregatesFilter<"Instructor"> | Date | string
    favoriteFood?: StringWithAggregatesFilter<"Instructor"> | string
    hobby?: StringWithAggregatesFilter<"Instructor"> | string
    lifeHistory?: StringWithAggregatesFilter<"Instructor"> | string
    messageForChildren?: StringWithAggregatesFilter<"Instructor"> | string
    skill?: StringWithAggregatesFilter<"Instructor"> | string
    workingTime?: StringWithAggregatesFilter<"Instructor"> | string
    terminationAt?: DateTimeNullableWithAggregatesFilter<"Instructor"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Instructor"> | Date | string
    isNative?: BoolWithAggregatesFilter<"Instructor"> | boolean
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    name?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    prefecture?: StringFilter<"Customer"> | string
    emailVerified?: DateTimeNullableFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    hasSeenWelcome?: BoolFilter<"Customer"> | boolean
    terminationAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    children?: ChildListRelationFilter
    classes?: ClassListRelationFilter
    subscription?: SubscriptionListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prefecture?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasSeenWelcome?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    children?: ChildOrderByRelationAggregateInput
    classes?: ClassOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    prefecture?: StringFilter<"Customer"> | string
    emailVerified?: DateTimeNullableFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    hasSeenWelcome?: BoolFilter<"Customer"> | boolean
    terminationAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    children?: ChildListRelationFilter
    classes?: ClassListRelationFilter
    subscription?: SubscriptionListRelationFilter
  }, "id" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prefecture?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasSeenWelcome?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    name?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    prefecture?: StringWithAggregatesFilter<"Customer"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    hasSeenWelcome?: BoolWithAggregatesFilter<"Customer"> | boolean
    terminationAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: IntFilter<"Class"> | number
    instructorId?: IntNullableFilter<"Class"> | number | null
    customerId?: IntFilter<"Class"> | number
    recurringClassId?: IntNullableFilter<"Class"> | number | null
    dateTime?: DateTimeNullableFilter<"Class"> | Date | string | null
    status?: EnumStatusFilter<"Class"> | $Enums.Status
    subscriptionId?: IntNullableFilter<"Class"> | number | null
    rebookableUntil?: DateTimeNullableFilter<"Class"> | Date | string | null
    classCode?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    isFreeTrial?: BoolFilter<"Class"> | boolean
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    instructor?: XOR<InstructorNullableScalarRelationFilter, InstructorWhereInput> | null
    recurringClass?: XOR<RecurringClassNullableScalarRelationFilter, RecurringClassWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    classAttendance?: ClassAttendanceListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrderInput | SortOrder
    dateTime?: SortOrderInput | SortOrder
    status?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    rebookableUntil?: SortOrderInput | SortOrder
    classCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFreeTrial?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    instructor?: InstructorOrderByWithRelationInput
    recurringClass?: RecurringClassOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    classAttendance?: ClassAttendanceOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    instructorId?: IntNullableFilter<"Class"> | number | null
    customerId?: IntFilter<"Class"> | number
    recurringClassId?: IntNullableFilter<"Class"> | number | null
    dateTime?: DateTimeNullableFilter<"Class"> | Date | string | null
    status?: EnumStatusFilter<"Class"> | $Enums.Status
    subscriptionId?: IntNullableFilter<"Class"> | number | null
    rebookableUntil?: DateTimeNullableFilter<"Class"> | Date | string | null
    classCode?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    isFreeTrial?: BoolFilter<"Class"> | boolean
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    instructor?: XOR<InstructorNullableScalarRelationFilter, InstructorWhereInput> | null
    recurringClass?: XOR<RecurringClassNullableScalarRelationFilter, RecurringClassWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    classAttendance?: ClassAttendanceListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrderInput | SortOrder
    dateTime?: SortOrderInput | SortOrder
    status?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    rebookableUntil?: SortOrderInput | SortOrder
    classCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFreeTrial?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Class"> | number
    instructorId?: IntNullableWithAggregatesFilter<"Class"> | number | null
    customerId?: IntWithAggregatesFilter<"Class"> | number
    recurringClassId?: IntNullableWithAggregatesFilter<"Class"> | number | null
    dateTime?: DateTimeNullableWithAggregatesFilter<"Class"> | Date | string | null
    status?: EnumStatusWithAggregatesFilter<"Class"> | $Enums.Status
    subscriptionId?: IntNullableWithAggregatesFilter<"Class"> | number | null
    rebookableUntil?: DateTimeNullableWithAggregatesFilter<"Class"> | Date | string | null
    classCode?: StringWithAggregatesFilter<"Class"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    isFreeTrial?: BoolWithAggregatesFilter<"Class"> | boolean
  }

  export type ClassAttendanceWhereInput = {
    AND?: ClassAttendanceWhereInput | ClassAttendanceWhereInput[]
    OR?: ClassAttendanceWhereInput[]
    NOT?: ClassAttendanceWhereInput | ClassAttendanceWhereInput[]
    classId?: IntFilter<"ClassAttendance"> | number
    childrenId?: IntFilter<"ClassAttendance"> | number
    children?: XOR<ChildScalarRelationFilter, ChildWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }

  export type ClassAttendanceOrderByWithRelationInput = {
    classId?: SortOrder
    childrenId?: SortOrder
    children?: ChildOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type ClassAttendanceWhereUniqueInput = Prisma.AtLeast<{
    classId_childrenId?: ClassAttendanceClassIdChildrenIdCompoundUniqueInput
    AND?: ClassAttendanceWhereInput | ClassAttendanceWhereInput[]
    OR?: ClassAttendanceWhereInput[]
    NOT?: ClassAttendanceWhereInput | ClassAttendanceWhereInput[]
    classId?: IntFilter<"ClassAttendance"> | number
    childrenId?: IntFilter<"ClassAttendance"> | number
    children?: XOR<ChildScalarRelationFilter, ChildWhereInput>
    class?: XOR<ClassScalarRelationFilter, ClassWhereInput>
  }, "classId_childrenId">

  export type ClassAttendanceOrderByWithAggregationInput = {
    classId?: SortOrder
    childrenId?: SortOrder
    _count?: ClassAttendanceCountOrderByAggregateInput
    _avg?: ClassAttendanceAvgOrderByAggregateInput
    _max?: ClassAttendanceMaxOrderByAggregateInput
    _min?: ClassAttendanceMinOrderByAggregateInput
    _sum?: ClassAttendanceSumOrderByAggregateInput
  }

  export type ClassAttendanceScalarWhereWithAggregatesInput = {
    AND?: ClassAttendanceScalarWhereWithAggregatesInput | ClassAttendanceScalarWhereWithAggregatesInput[]
    OR?: ClassAttendanceScalarWhereWithAggregatesInput[]
    NOT?: ClassAttendanceScalarWhereWithAggregatesInput | ClassAttendanceScalarWhereWithAggregatesInput[]
    classId?: IntWithAggregatesFilter<"ClassAttendance"> | number
    childrenId?: IntWithAggregatesFilter<"ClassAttendance"> | number
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: IntFilter<"Plan"> | number
    name?: StringFilter<"Plan"> | string
    description?: StringFilter<"Plan"> | string
    weeklyClassTimes?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    terminationAt?: DateTimeNullableFilter<"Plan"> | Date | string | null
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    isNative?: BoolFilter<"Plan"> | boolean
    subscription?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weeklyClassTimes?: SortOrder
    createdAt?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
    subscription?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringFilter<"Plan"> | string
    weeklyClassTimes?: IntFilter<"Plan"> | number
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    terminationAt?: DateTimeNullableFilter<"Plan"> | Date | string | null
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    isNative?: BoolFilter<"Plan"> | boolean
    subscription?: SubscriptionListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weeklyClassTimes?: SortOrder
    createdAt?: SortOrder
    terminationAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Plan"> | number
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringWithAggregatesFilter<"Plan"> | string
    weeklyClassTimes?: IntWithAggregatesFilter<"Plan"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    terminationAt?: DateTimeNullableWithAggregatesFilter<"Plan"> | Date | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    isNative?: BoolWithAggregatesFilter<"Plan"> | boolean
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: IntFilter<"Subscription"> | number
    planId?: IntFilter<"Subscription"> | number
    customerId?: IntFilter<"Subscription"> | number
    startAt?: DateTimeFilter<"Subscription"> | Date | string
    endAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    class?: ClassListRelationFilter
    recurringClass?: RecurringClassListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    class?: ClassOrderByRelationAggregateInput
    recurringClass?: RecurringClassOrderByRelationAggregateInput
    customer?: CustomerOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    planId?: IntFilter<"Subscription"> | number
    customerId?: IntFilter<"Subscription"> | number
    startAt?: DateTimeFilter<"Subscription"> | Date | string
    endAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    class?: ClassListRelationFilter
    recurringClass?: RecurringClassListRelationFilter
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrderInput | SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Subscription"> | number
    planId?: IntWithAggregatesFilter<"Subscription"> | number
    customerId?: IntWithAggregatesFilter<"Subscription"> | number
    startAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
  }

  export type RecurringClassWhereInput = {
    AND?: RecurringClassWhereInput | RecurringClassWhereInput[]
    OR?: RecurringClassWhereInput[]
    NOT?: RecurringClassWhereInput | RecurringClassWhereInput[]
    id?: IntFilter<"RecurringClass"> | number
    instructorId?: IntNullableFilter<"RecurringClass"> | number | null
    subscriptionId?: IntNullableFilter<"RecurringClass"> | number | null
    startAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
    endAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
    classes?: ClassListRelationFilter
    instructor?: XOR<InstructorNullableScalarRelationFilter, InstructorWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    recurringClassAttendance?: RecurringClassAttendanceListRelationFilter
  }

  export type RecurringClassOrderByWithRelationInput = {
    id?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    classes?: ClassOrderByRelationAggregateInput
    instructor?: InstructorOrderByWithRelationInput
    subscription?: SubscriptionOrderByWithRelationInput
    recurringClassAttendance?: RecurringClassAttendanceOrderByRelationAggregateInput
  }

  export type RecurringClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RecurringClassWhereInput | RecurringClassWhereInput[]
    OR?: RecurringClassWhereInput[]
    NOT?: RecurringClassWhereInput | RecurringClassWhereInput[]
    instructorId?: IntNullableFilter<"RecurringClass"> | number | null
    subscriptionId?: IntNullableFilter<"RecurringClass"> | number | null
    startAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
    endAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
    classes?: ClassListRelationFilter
    instructor?: XOR<InstructorNullableScalarRelationFilter, InstructorWhereInput> | null
    subscription?: XOR<SubscriptionNullableScalarRelationFilter, SubscriptionWhereInput> | null
    recurringClassAttendance?: RecurringClassAttendanceListRelationFilter
  }, "id">

  export type RecurringClassOrderByWithAggregationInput = {
    id?: SortOrder
    instructorId?: SortOrderInput | SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    _count?: RecurringClassCountOrderByAggregateInput
    _avg?: RecurringClassAvgOrderByAggregateInput
    _max?: RecurringClassMaxOrderByAggregateInput
    _min?: RecurringClassMinOrderByAggregateInput
    _sum?: RecurringClassSumOrderByAggregateInput
  }

  export type RecurringClassScalarWhereWithAggregatesInput = {
    AND?: RecurringClassScalarWhereWithAggregatesInput | RecurringClassScalarWhereWithAggregatesInput[]
    OR?: RecurringClassScalarWhereWithAggregatesInput[]
    NOT?: RecurringClassScalarWhereWithAggregatesInput | RecurringClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RecurringClass"> | number
    instructorId?: IntNullableWithAggregatesFilter<"RecurringClass"> | number | null
    subscriptionId?: IntNullableWithAggregatesFilter<"RecurringClass"> | number | null
    startAt?: DateTimeNullableWithAggregatesFilter<"RecurringClass"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"RecurringClass"> | Date | string | null
  }

  export type RecurringClassAttendanceWhereInput = {
    AND?: RecurringClassAttendanceWhereInput | RecurringClassAttendanceWhereInput[]
    OR?: RecurringClassAttendanceWhereInput[]
    NOT?: RecurringClassAttendanceWhereInput | RecurringClassAttendanceWhereInput[]
    recurringClassId?: IntFilter<"RecurringClassAttendance"> | number
    childrenId?: IntFilter<"RecurringClassAttendance"> | number
    children?: XOR<ChildScalarRelationFilter, ChildWhereInput>
    recurringClass?: XOR<RecurringClassScalarRelationFilter, RecurringClassWhereInput>
  }

  export type RecurringClassAttendanceOrderByWithRelationInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
    children?: ChildOrderByWithRelationInput
    recurringClass?: RecurringClassOrderByWithRelationInput
  }

  export type RecurringClassAttendanceWhereUniqueInput = Prisma.AtLeast<{
    recurringClassId_childrenId?: RecurringClassAttendanceRecurringClassIdChildrenIdCompoundUniqueInput
    AND?: RecurringClassAttendanceWhereInput | RecurringClassAttendanceWhereInput[]
    OR?: RecurringClassAttendanceWhereInput[]
    NOT?: RecurringClassAttendanceWhereInput | RecurringClassAttendanceWhereInput[]
    recurringClassId?: IntFilter<"RecurringClassAttendance"> | number
    childrenId?: IntFilter<"RecurringClassAttendance"> | number
    children?: XOR<ChildScalarRelationFilter, ChildWhereInput>
    recurringClass?: XOR<RecurringClassScalarRelationFilter, RecurringClassWhereInput>
  }, "recurringClassId_childrenId">

  export type RecurringClassAttendanceOrderByWithAggregationInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
    _count?: RecurringClassAttendanceCountOrderByAggregateInput
    _avg?: RecurringClassAttendanceAvgOrderByAggregateInput
    _max?: RecurringClassAttendanceMaxOrderByAggregateInput
    _min?: RecurringClassAttendanceMinOrderByAggregateInput
    _sum?: RecurringClassAttendanceSumOrderByAggregateInput
  }

  export type RecurringClassAttendanceScalarWhereWithAggregatesInput = {
    AND?: RecurringClassAttendanceScalarWhereWithAggregatesInput | RecurringClassAttendanceScalarWhereWithAggregatesInput[]
    OR?: RecurringClassAttendanceScalarWhereWithAggregatesInput[]
    NOT?: RecurringClassAttendanceScalarWhereWithAggregatesInput | RecurringClassAttendanceScalarWhereWithAggregatesInput[]
    recurringClassId?: IntWithAggregatesFilter<"RecurringClassAttendance"> | number
    childrenId?: IntWithAggregatesFilter<"RecurringClassAttendance"> | number
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: IntFilter<"Schedule"> | number
    date?: DateTimeFilter<"Schedule"> | Date | string
    eventId?: IntFilter<"Schedule"> | number
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    eventId?: SortOrder
    event?: EventOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    date?: Date | string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    eventId?: IntFilter<"Schedule"> | number
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
  }, "id" | "date">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    eventId?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Schedule"> | number
    date?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    eventId?: IntWithAggregatesFilter<"Schedule"> | number
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: IntFilter<"Event"> | number
    name?: StringFilter<"Event"> | string
    color?: StringFilter<"Event"> | string
    Schedule?: ScheduleListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    Schedule?: ScheduleOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    color?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    Schedule?: ScheduleListRelationFilter
  }, "id" | "name" | "color">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Event"> | number
    name?: StringWithAggregatesFilter<"Event"> | string
    color?: StringWithAggregatesFilter<"Event"> | string
  }

  export type InstructorScheduleWhereInput = {
    AND?: InstructorScheduleWhereInput | InstructorScheduleWhereInput[]
    OR?: InstructorScheduleWhereInput[]
    NOT?: InstructorScheduleWhereInput | InstructorScheduleWhereInput[]
    id?: IntFilter<"InstructorSchedule"> | number
    instructorId?: IntFilter<"InstructorSchedule"> | number
    effectiveFrom?: DateTimeFilter<"InstructorSchedule"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"InstructorSchedule"> | Date | string | null
    timezone?: StringFilter<"InstructorSchedule"> | string
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
    slots?: InstructorSlotListRelationFilter
  }

  export type InstructorScheduleOrderByWithRelationInput = {
    id?: SortOrder
    instructorId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    timezone?: SortOrder
    instructor?: InstructorOrderByWithRelationInput
    slots?: InstructorSlotOrderByRelationAggregateInput
  }

  export type InstructorScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    instructorId_effectiveTo?: InstructorScheduleInstructorIdEffectiveToCompoundUniqueInput
    AND?: InstructorScheduleWhereInput | InstructorScheduleWhereInput[]
    OR?: InstructorScheduleWhereInput[]
    NOT?: InstructorScheduleWhereInput | InstructorScheduleWhereInput[]
    instructorId?: IntFilter<"InstructorSchedule"> | number
    effectiveFrom?: DateTimeFilter<"InstructorSchedule"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"InstructorSchedule"> | Date | string | null
    timezone?: StringFilter<"InstructorSchedule"> | string
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
    slots?: InstructorSlotListRelationFilter
  }, "id" | "instructorId_effectiveTo">

  export type InstructorScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    instructorId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    timezone?: SortOrder
    _count?: InstructorScheduleCountOrderByAggregateInput
    _avg?: InstructorScheduleAvgOrderByAggregateInput
    _max?: InstructorScheduleMaxOrderByAggregateInput
    _min?: InstructorScheduleMinOrderByAggregateInput
    _sum?: InstructorScheduleSumOrderByAggregateInput
  }

  export type InstructorScheduleScalarWhereWithAggregatesInput = {
    AND?: InstructorScheduleScalarWhereWithAggregatesInput | InstructorScheduleScalarWhereWithAggregatesInput[]
    OR?: InstructorScheduleScalarWhereWithAggregatesInput[]
    NOT?: InstructorScheduleScalarWhereWithAggregatesInput | InstructorScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InstructorSchedule"> | number
    instructorId?: IntWithAggregatesFilter<"InstructorSchedule"> | number
    effectiveFrom?: DateTimeWithAggregatesFilter<"InstructorSchedule"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"InstructorSchedule"> | Date | string | null
    timezone?: StringWithAggregatesFilter<"InstructorSchedule"> | string
  }

  export type InstructorSlotWhereInput = {
    AND?: InstructorSlotWhereInput | InstructorSlotWhereInput[]
    OR?: InstructorSlotWhereInput[]
    NOT?: InstructorSlotWhereInput | InstructorSlotWhereInput[]
    scheduleId?: IntFilter<"InstructorSlot"> | number
    weekday?: IntFilter<"InstructorSlot"> | number
    startTime?: DateTimeFilter<"InstructorSlot"> | Date | string
    schedule?: XOR<InstructorScheduleScalarRelationFilter, InstructorScheduleWhereInput>
  }

  export type InstructorSlotOrderByWithRelationInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    schedule?: InstructorScheduleOrderByWithRelationInput
  }

  export type InstructorSlotWhereUniqueInput = Prisma.AtLeast<{
    scheduleId_weekday_startTime?: InstructorSlotScheduleIdWeekdayStartTimeCompoundUniqueInput
    AND?: InstructorSlotWhereInput | InstructorSlotWhereInput[]
    OR?: InstructorSlotWhereInput[]
    NOT?: InstructorSlotWhereInput | InstructorSlotWhereInput[]
    scheduleId?: IntFilter<"InstructorSlot"> | number
    weekday?: IntFilter<"InstructorSlot"> | number
    startTime?: DateTimeFilter<"InstructorSlot"> | Date | string
    schedule?: XOR<InstructorScheduleScalarRelationFilter, InstructorScheduleWhereInput>
  }, "scheduleId_weekday_startTime">

  export type InstructorSlotOrderByWithAggregationInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
    _count?: InstructorSlotCountOrderByAggregateInput
    _avg?: InstructorSlotAvgOrderByAggregateInput
    _max?: InstructorSlotMaxOrderByAggregateInput
    _min?: InstructorSlotMinOrderByAggregateInput
    _sum?: InstructorSlotSumOrderByAggregateInput
  }

  export type InstructorSlotScalarWhereWithAggregatesInput = {
    AND?: InstructorSlotScalarWhereWithAggregatesInput | InstructorSlotScalarWhereWithAggregatesInput[]
    OR?: InstructorSlotScalarWhereWithAggregatesInput[]
    NOT?: InstructorSlotScalarWhereWithAggregatesInput | InstructorSlotScalarWhereWithAggregatesInput[]
    scheduleId?: IntWithAggregatesFilter<"InstructorSlot"> | number
    weekday?: IntWithAggregatesFilter<"InstructorSlot"> | number
    startTime?: DateTimeWithAggregatesFilter<"InstructorSlot"> | Date | string
  }

  export type InstructorAbsenceWhereInput = {
    AND?: InstructorAbsenceWhereInput | InstructorAbsenceWhereInput[]
    OR?: InstructorAbsenceWhereInput[]
    NOT?: InstructorAbsenceWhereInput | InstructorAbsenceWhereInput[]
    instructorId?: IntFilter<"InstructorAbsence"> | number
    absentAt?: DateTimeFilter<"InstructorAbsence"> | Date | string
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
  }

  export type InstructorAbsenceOrderByWithRelationInput = {
    instructorId?: SortOrder
    absentAt?: SortOrder
    instructor?: InstructorOrderByWithRelationInput
  }

  export type InstructorAbsenceWhereUniqueInput = Prisma.AtLeast<{
    instructorId_absentAt?: InstructorAbsenceInstructorIdAbsentAtCompoundUniqueInput
    AND?: InstructorAbsenceWhereInput | InstructorAbsenceWhereInput[]
    OR?: InstructorAbsenceWhereInput[]
    NOT?: InstructorAbsenceWhereInput | InstructorAbsenceWhereInput[]
    instructorId?: IntFilter<"InstructorAbsence"> | number
    absentAt?: DateTimeFilter<"InstructorAbsence"> | Date | string
    instructor?: XOR<InstructorScalarRelationFilter, InstructorWhereInput>
  }, "instructorId_absentAt">

  export type InstructorAbsenceOrderByWithAggregationInput = {
    instructorId?: SortOrder
    absentAt?: SortOrder
    _count?: InstructorAbsenceCountOrderByAggregateInput
    _avg?: InstructorAbsenceAvgOrderByAggregateInput
    _max?: InstructorAbsenceMaxOrderByAggregateInput
    _min?: InstructorAbsenceMinOrderByAggregateInput
    _sum?: InstructorAbsenceSumOrderByAggregateInput
  }

  export type InstructorAbsenceScalarWhereWithAggregatesInput = {
    AND?: InstructorAbsenceScalarWhereWithAggregatesInput | InstructorAbsenceScalarWhereWithAggregatesInput[]
    OR?: InstructorAbsenceScalarWhereWithAggregatesInput[]
    NOT?: InstructorAbsenceScalarWhereWithAggregatesInput | InstructorAbsenceScalarWhereWithAggregatesInput[]
    instructorId?: IntWithAggregatesFilter<"InstructorAbsence"> | number
    absentAt?: DateTimeWithAggregatesFilter<"InstructorAbsence"> | Date | string
  }

  export type SystemStatusWhereInput = {
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    id?: IntFilter<"SystemStatus"> | number
    status?: StringFilter<"SystemStatus"> | string
    createdAt?: DateTimeFilter<"SystemStatus"> | Date | string
    updatedAt?: DateTimeFilter<"SystemStatus"> | Date | string
  }

  export type SystemStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SystemStatusWhereInput | SystemStatusWhereInput[]
    OR?: SystemStatusWhereInput[]
    NOT?: SystemStatusWhereInput | SystemStatusWhereInput[]
    status?: StringFilter<"SystemStatus"> | string
    createdAt?: DateTimeFilter<"SystemStatus"> | Date | string
    updatedAt?: DateTimeFilter<"SystemStatus"> | Date | string
  }, "id">

  export type SystemStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemStatusCountOrderByAggregateInput
    _avg?: SystemStatusAvgOrderByAggregateInput
    _max?: SystemStatusMaxOrderByAggregateInput
    _min?: SystemStatusMinOrderByAggregateInput
    _sum?: SystemStatusSumOrderByAggregateInput
  }

  export type SystemStatusScalarWhereWithAggregatesInput = {
    AND?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    OR?: SystemStatusScalarWhereWithAggregatesInput[]
    NOT?: SystemStatusScalarWhereWithAggregatesInput | SystemStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SystemStatus"> | number
    status?: StringWithAggregatesFilter<"SystemStatus"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemStatus"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ChildWhereInput = {
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    id?: IntFilter<"Child"> | number
    customerId?: IntFilter<"Child"> | number
    name?: StringFilter<"Child"> | string
    birthdate?: DateTimeNullableFilter<"Child"> | Date | string | null
    personalInfo?: StringNullableFilter<"Child"> | string | null
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    classAttendance?: ClassAttendanceListRelationFilter
    recurringClassAttendance?: RecurringClassAttendanceListRelationFilter
  }

  export type ChildOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    birthdate?: SortOrderInput | SortOrder
    personalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    classAttendance?: ClassAttendanceOrderByRelationAggregateInput
    recurringClassAttendance?: RecurringClassAttendanceOrderByRelationAggregateInput
  }

  export type ChildWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ChildWhereInput | ChildWhereInput[]
    OR?: ChildWhereInput[]
    NOT?: ChildWhereInput | ChildWhereInput[]
    customerId?: IntFilter<"Child"> | number
    name?: StringFilter<"Child"> | string
    birthdate?: DateTimeNullableFilter<"Child"> | Date | string | null
    personalInfo?: StringNullableFilter<"Child"> | string | null
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    classAttendance?: ClassAttendanceListRelationFilter
    recurringClassAttendance?: RecurringClassAttendanceListRelationFilter
  }, "id">

  export type ChildOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    birthdate?: SortOrderInput | SortOrder
    personalInfo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChildCountOrderByAggregateInput
    _avg?: ChildAvgOrderByAggregateInput
    _max?: ChildMaxOrderByAggregateInput
    _min?: ChildMinOrderByAggregateInput
    _sum?: ChildSumOrderByAggregateInput
  }

  export type ChildScalarWhereWithAggregatesInput = {
    AND?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    OR?: ChildScalarWhereWithAggregatesInput[]
    NOT?: ChildScalarWhereWithAggregatesInput | ChildScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Child"> | number
    customerId?: IntWithAggregatesFilter<"Child"> | number
    name?: StringWithAggregatesFilter<"Child"> | string
    birthdate?: DateTimeNullableWithAggregatesFilter<"Child"> | Date | string | null
    personalInfo?: StringNullableWithAggregatesFilter<"Child"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Child"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Child"> | Date | string
  }

  export type InstructorCreateInput = {
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassUncheckedCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceUncheckedCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleUncheckedCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUncheckedUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUncheckedUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
  }

  export type InstructorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstructorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerCreateInput = {
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildCreateNestedManyWithoutCustomerInput
    classes?: ClassCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildUncheckedCreateNestedManyWithoutCustomerInput
    classes?: ClassUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUpdateManyWithoutCustomerNestedInput
    classes?: ClassUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUncheckedUpdateManyWithoutCustomerNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
  }

  export type CustomerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassCreateInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    customer: CustomerCreateNestedOneWithoutClassesInput
    instructor?: InstructorCreateNestedOneWithoutClassesInput
    recurringClass?: RecurringClassCreateNestedOneWithoutClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutClassInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutClassesNestedInput
    instructor?: InstructorUpdateOneWithoutClassesNestedInput
    recurringClass?: RecurringClassUpdateOneWithoutClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutClassNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type ClassUpdateManyMutationInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassAttendanceCreateInput = {
    children: ChildCreateNestedOneWithoutClassAttendanceInput
    class: ClassCreateNestedOneWithoutClassAttendanceInput
  }

  export type ClassAttendanceUncheckedCreateInput = {
    classId: number
    childrenId: number
  }

  export type ClassAttendanceUpdateInput = {
    children?: ChildUpdateOneRequiredWithoutClassAttendanceNestedInput
    class?: ClassUpdateOneRequiredWithoutClassAttendanceNestedInput
  }

  export type ClassAttendanceUncheckedUpdateInput = {
    classId?: IntFieldUpdateOperationsInput | number
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassAttendanceCreateManyInput = {
    classId: number
    childrenId: number
  }

  export type ClassAttendanceUpdateManyMutationInput = {

  }

  export type ClassAttendanceUncheckedUpdateManyInput = {
    classId?: IntFieldUpdateOperationsInput | number
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type PlanCreateInput = {
    name: string
    description: string
    weeklyClassTimes: number
    createdAt?: Date | string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    subscription?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    weeklyClassTimes: number
    createdAt?: Date | string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    subscription?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    subscription?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: number
    name: string
    description: string
    weeklyClassTimes: number
    createdAt?: Date | string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
  }

  export type PlanUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionCreateInput = {
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassCreateNestedManyWithoutSubscriptionInput
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: number
    planId: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassUncheckedCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUpdateManyWithoutSubscriptionNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUncheckedUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: number
    planId: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
  }

  export type SubscriptionUpdateManyMutationInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringClassCreateInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassCreateNestedManyWithoutRecurringClassInput
    instructor?: InstructorCreateNestedOneWithoutRecurringClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassUncheckedCreateInput = {
    id?: number
    instructorId?: number | null
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassUncheckedCreateNestedManyWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassUpdateInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUpdateManyWithoutRecurringClassNestedInput
    instructor?: InstructorUpdateOneWithoutRecurringClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUncheckedUpdateManyWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassCreateManyInput = {
    id?: number
    instructorId?: number | null
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
  }

  export type RecurringClassUpdateManyMutationInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RecurringClassAttendanceCreateInput = {
    children: ChildCreateNestedOneWithoutRecurringClassAttendanceInput
    recurringClass: RecurringClassCreateNestedOneWithoutRecurringClassAttendanceInput
  }

  export type RecurringClassAttendanceUncheckedCreateInput = {
    recurringClassId: number
    childrenId: number
  }

  export type RecurringClassAttendanceUpdateInput = {
    children?: ChildUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput
    recurringClass?: RecurringClassUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput
  }

  export type RecurringClassAttendanceUncheckedUpdateInput = {
    recurringClassId?: IntFieldUpdateOperationsInput | number
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringClassAttendanceCreateManyInput = {
    recurringClassId: number
    childrenId: number
  }

  export type RecurringClassAttendanceUpdateManyMutationInput = {

  }

  export type RecurringClassAttendanceUncheckedUpdateManyInput = {
    recurringClassId?: IntFieldUpdateOperationsInput | number
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    date: Date | string
    event: EventCreateNestedOneWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: number
    date: Date | string
    eventId: number
  }

  export type ScheduleUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleCreateManyInput = {
    id?: number
    date: Date | string
    eventId: number
  }

  export type ScheduleUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    eventId?: IntFieldUpdateOperationsInput | number
  }

  export type EventCreateInput = {
    name: string
    color: string
    Schedule?: ScheduleCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    Schedule?: ScheduleUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    Schedule?: ScheduleUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    Schedule?: ScheduleUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: number
    name: string
    color: string
  }

  export type EventUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorScheduleCreateInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
    instructor: InstructorCreateNestedOneWithoutInstructorSchedulesInput
    slots?: InstructorSlotCreateNestedManyWithoutScheduleInput
  }

  export type InstructorScheduleUncheckedCreateInput = {
    id?: number
    instructorId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
    slots?: InstructorSlotUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type InstructorScheduleUpdateInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    instructor?: InstructorUpdateOneRequiredWithoutInstructorSchedulesNestedInput
    slots?: InstructorSlotUpdateManyWithoutScheduleNestedInput
  }

  export type InstructorScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    slots?: InstructorSlotUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type InstructorScheduleCreateManyInput = {
    id?: number
    instructorId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
  }

  export type InstructorScheduleUpdateManyMutationInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorSlotCreateInput = {
    weekday: number
    startTime: Date | string
    schedule: InstructorScheduleCreateNestedOneWithoutSlotsInput
  }

  export type InstructorSlotUncheckedCreateInput = {
    scheduleId: number
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotUpdateInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: InstructorScheduleUpdateOneRequiredWithoutSlotsNestedInput
  }

  export type InstructorSlotUncheckedUpdateInput = {
    scheduleId?: IntFieldUpdateOperationsInput | number
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorSlotCreateManyInput = {
    scheduleId: number
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotUpdateManyMutationInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorSlotUncheckedUpdateManyInput = {
    scheduleId?: IntFieldUpdateOperationsInput | number
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorAbsenceCreateInput = {
    absentAt: Date | string
    instructor: InstructorCreateNestedOneWithoutInstructorAbsencesInput
  }

  export type InstructorAbsenceUncheckedCreateInput = {
    instructorId: number
    absentAt: Date | string
  }

  export type InstructorAbsenceUpdateInput = {
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: InstructorUpdateOneRequiredWithoutInstructorAbsencesNestedInput
  }

  export type InstructorAbsenceUncheckedUpdateInput = {
    instructorId?: IntFieldUpdateOperationsInput | number
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorAbsenceCreateManyInput = {
    instructorId: number
    absentAt: Date | string
  }

  export type InstructorAbsenceUpdateManyMutationInput = {
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorAbsenceUncheckedUpdateManyInput = {
    instructorId?: IntFieldUpdateOperationsInput | number
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateInput = {
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemStatusUncheckedCreateInput = {
    id?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemStatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusCreateManyInput = {
    id?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemStatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildCreateInput = {
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutChildrenInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutChildrenInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutChildrenInput
  }

  export type ChildUncheckedCreateInput = {
    id?: number
    customerId: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
  }

  export type ChildUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutChildrenNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutChildrenNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
  }

  export type ChildCreateManyInput = {
    id?: number
    customerId: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChildUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChildUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClassListRelationFilter = {
    every?: ClassWhereInput
    some?: ClassWhereInput
    none?: ClassWhereInput
  }

  export type InstructorAbsenceListRelationFilter = {
    every?: InstructorAbsenceWhereInput
    some?: InstructorAbsenceWhereInput
    none?: InstructorAbsenceWhereInput
  }

  export type InstructorScheduleListRelationFilter = {
    every?: InstructorScheduleWhereInput
    some?: InstructorScheduleWhereInput
    none?: InstructorScheduleWhereInput
  }

  export type RecurringClassListRelationFilter = {
    every?: RecurringClassWhereInput
    some?: RecurringClassWhereInput
    none?: RecurringClassWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructorAbsenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructorScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    classURL?: SortOrder
    icon?: SortOrder
    nickname?: SortOrder
    meetingId?: SortOrder
    passcode?: SortOrder
    createdAt?: SortOrder
    birthdate?: SortOrder
    favoriteFood?: SortOrder
    hobby?: SortOrder
    lifeHistory?: SortOrder
    messageForChildren?: SortOrder
    skill?: SortOrder
    workingTime?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type InstructorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InstructorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    classURL?: SortOrder
    icon?: SortOrder
    nickname?: SortOrder
    meetingId?: SortOrder
    passcode?: SortOrder
    createdAt?: SortOrder
    birthdate?: SortOrder
    favoriteFood?: SortOrder
    hobby?: SortOrder
    lifeHistory?: SortOrder
    messageForChildren?: SortOrder
    skill?: SortOrder
    workingTime?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type InstructorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    classURL?: SortOrder
    icon?: SortOrder
    nickname?: SortOrder
    meetingId?: SortOrder
    passcode?: SortOrder
    createdAt?: SortOrder
    birthdate?: SortOrder
    favoriteFood?: SortOrder
    hobby?: SortOrder
    lifeHistory?: SortOrder
    messageForChildren?: SortOrder
    skill?: SortOrder
    workingTime?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type InstructorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ChildListRelationFilter = {
    every?: ChildWhereInput
    some?: ChildWhereInput
    none?: ChildWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type ChildOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prefecture?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasSeenWelcome?: SortOrder
    terminationAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prefecture?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasSeenWelcome?: SortOrder
    terminationAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    prefecture?: SortOrder
    emailVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hasSeenWelcome?: SortOrder
    terminationAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type InstructorNullableScalarRelationFilter = {
    is?: InstructorWhereInput | null
    isNot?: InstructorWhereInput | null
  }

  export type RecurringClassNullableScalarRelationFilter = {
    is?: RecurringClassWhereInput | null
    isNot?: RecurringClassWhereInput | null
  }

  export type SubscriptionNullableScalarRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type ClassAttendanceListRelationFilter = {
    every?: ClassAttendanceWhereInput
    some?: ClassAttendanceWhereInput
    none?: ClassAttendanceWhereInput
  }

  export type ClassAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrder
    dateTime?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    rebookableUntil?: SortOrder
    classCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFreeTrial?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrder
    dateTime?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    rebookableUntil?: SortOrder
    classCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFreeTrial?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrder
    dateTime?: SortOrder
    status?: SortOrder
    subscriptionId?: SortOrder
    rebookableUntil?: SortOrder
    classCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isFreeTrial?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    customerId?: SortOrder
    recurringClassId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type ChildScalarRelationFilter = {
    is?: ChildWhereInput
    isNot?: ChildWhereInput
  }

  export type ClassScalarRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ClassAttendanceClassIdChildrenIdCompoundUniqueInput = {
    classId: number
    childrenId: number
  }

  export type ClassAttendanceCountOrderByAggregateInput = {
    classId?: SortOrder
    childrenId?: SortOrder
  }

  export type ClassAttendanceAvgOrderByAggregateInput = {
    classId?: SortOrder
    childrenId?: SortOrder
  }

  export type ClassAttendanceMaxOrderByAggregateInput = {
    classId?: SortOrder
    childrenId?: SortOrder
  }

  export type ClassAttendanceMinOrderByAggregateInput = {
    classId?: SortOrder
    childrenId?: SortOrder
  }

  export type ClassAttendanceSumOrderByAggregateInput = {
    classId?: SortOrder
    childrenId?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weeklyClassTimes?: SortOrder
    createdAt?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    id?: SortOrder
    weeklyClassTimes?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weeklyClassTimes?: SortOrder
    createdAt?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    weeklyClassTimes?: SortOrder
    createdAt?: SortOrder
    terminationAt?: SortOrder
    updatedAt?: SortOrder
    isNative?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    id?: SortOrder
    weeklyClassTimes?: SortOrder
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    customerId?: SortOrder
  }

  export type RecurringClassAttendanceListRelationFilter = {
    every?: RecurringClassAttendanceWhereInput
    some?: RecurringClassAttendanceWhereInput
    none?: RecurringClassAttendanceWhereInput
  }

  export type RecurringClassAttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecurringClassCountOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    subscriptionId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type RecurringClassAvgOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type RecurringClassMaxOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    subscriptionId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type RecurringClassMinOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    subscriptionId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
  }

  export type RecurringClassSumOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    subscriptionId?: SortOrder
  }

  export type RecurringClassScalarRelationFilter = {
    is?: RecurringClassWhereInput
    isNot?: RecurringClassWhereInput
  }

  export type RecurringClassAttendanceRecurringClassIdChildrenIdCompoundUniqueInput = {
    recurringClassId: number
    childrenId: number
  }

  export type RecurringClassAttendanceCountOrderByAggregateInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
  }

  export type RecurringClassAttendanceAvgOrderByAggregateInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
  }

  export type RecurringClassAttendanceMaxOrderByAggregateInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
  }

  export type RecurringClassAttendanceMinOrderByAggregateInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
  }

  export type RecurringClassAttendanceSumOrderByAggregateInput = {
    recurringClassId?: SortOrder
    childrenId?: SortOrder
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    eventId?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    eventId?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    eventId?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InstructorScalarRelationFilter = {
    is?: InstructorWhereInput
    isNot?: InstructorWhereInput
  }

  export type InstructorSlotListRelationFilter = {
    every?: InstructorSlotWhereInput
    some?: InstructorSlotWhereInput
    none?: InstructorSlotWhereInput
  }

  export type InstructorSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructorScheduleInstructorIdEffectiveToCompoundUniqueInput = {
    instructorId: number
    effectiveTo: Date | string
  }

  export type InstructorScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    timezone?: SortOrder
  }

  export type InstructorScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
  }

  export type InstructorScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    timezone?: SortOrder
  }

  export type InstructorScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    timezone?: SortOrder
  }

  export type InstructorScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    instructorId?: SortOrder
  }

  export type InstructorScheduleScalarRelationFilter = {
    is?: InstructorScheduleWhereInput
    isNot?: InstructorScheduleWhereInput
  }

  export type InstructorSlotScheduleIdWeekdayStartTimeCompoundUniqueInput = {
    scheduleId: number
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotCountOrderByAggregateInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
  }

  export type InstructorSlotAvgOrderByAggregateInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
  }

  export type InstructorSlotMaxOrderByAggregateInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
  }

  export type InstructorSlotMinOrderByAggregateInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
    startTime?: SortOrder
  }

  export type InstructorSlotSumOrderByAggregateInput = {
    scheduleId?: SortOrder
    weekday?: SortOrder
  }

  export type InstructorAbsenceInstructorIdAbsentAtCompoundUniqueInput = {
    instructorId: number
    absentAt: Date | string
  }

  export type InstructorAbsenceCountOrderByAggregateInput = {
    instructorId?: SortOrder
    absentAt?: SortOrder
  }

  export type InstructorAbsenceAvgOrderByAggregateInput = {
    instructorId?: SortOrder
  }

  export type InstructorAbsenceMaxOrderByAggregateInput = {
    instructorId?: SortOrder
    absentAt?: SortOrder
  }

  export type InstructorAbsenceMinOrderByAggregateInput = {
    instructorId?: SortOrder
    absentAt?: SortOrder
  }

  export type InstructorAbsenceSumOrderByAggregateInput = {
    instructorId?: SortOrder
  }

  export type SystemStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SystemStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ChildCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    birthdate?: SortOrder
    personalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type ChildMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    birthdate?: SortOrder
    personalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    birthdate?: SortOrder
    personalInfo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChildSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClassCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput> | ClassCreateWithoutInstructorInput[] | ClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstructorInput | ClassCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassCreateManyInstructorInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type InstructorAbsenceCreateNestedManyWithoutInstructorInput = {
    create?: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput> | InstructorAbsenceCreateWithoutInstructorInput[] | InstructorAbsenceUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorAbsenceCreateOrConnectWithoutInstructorInput | InstructorAbsenceCreateOrConnectWithoutInstructorInput[]
    createMany?: InstructorAbsenceCreateManyInstructorInputEnvelope
    connect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
  }

  export type InstructorScheduleCreateNestedManyWithoutInstructorInput = {
    create?: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput> | InstructorScheduleCreateWithoutInstructorInput[] | InstructorScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutInstructorInput | InstructorScheduleCreateOrConnectWithoutInstructorInput[]
    createMany?: InstructorScheduleCreateManyInstructorInputEnvelope
    connect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
  }

  export type RecurringClassCreateNestedManyWithoutInstructorInput = {
    create?: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput> | RecurringClassCreateWithoutInstructorInput[] | RecurringClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutInstructorInput | RecurringClassCreateOrConnectWithoutInstructorInput[]
    createMany?: RecurringClassCreateManyInstructorInputEnvelope
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput> | ClassCreateWithoutInstructorInput[] | ClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstructorInput | ClassCreateOrConnectWithoutInstructorInput[]
    createMany?: ClassCreateManyInstructorInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type InstructorAbsenceUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput> | InstructorAbsenceCreateWithoutInstructorInput[] | InstructorAbsenceUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorAbsenceCreateOrConnectWithoutInstructorInput | InstructorAbsenceCreateOrConnectWithoutInstructorInput[]
    createMany?: InstructorAbsenceCreateManyInstructorInputEnvelope
    connect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
  }

  export type InstructorScheduleUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput> | InstructorScheduleCreateWithoutInstructorInput[] | InstructorScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutInstructorInput | InstructorScheduleCreateOrConnectWithoutInstructorInput[]
    createMany?: InstructorScheduleCreateManyInstructorInputEnvelope
    connect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
  }

  export type RecurringClassUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput> | RecurringClassCreateWithoutInstructorInput[] | RecurringClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutInstructorInput | RecurringClassCreateOrConnectWithoutInstructorInput[]
    createMany?: RecurringClassCreateManyInstructorInputEnvelope
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ClassUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput> | ClassCreateWithoutInstructorInput[] | ClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstructorInput | ClassCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutInstructorInput | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassCreateManyInstructorInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutInstructorInput | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutInstructorInput | ClassUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type InstructorAbsenceUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput> | InstructorAbsenceCreateWithoutInstructorInput[] | InstructorAbsenceUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorAbsenceCreateOrConnectWithoutInstructorInput | InstructorAbsenceCreateOrConnectWithoutInstructorInput[]
    upsert?: InstructorAbsenceUpsertWithWhereUniqueWithoutInstructorInput | InstructorAbsenceUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: InstructorAbsenceCreateManyInstructorInputEnvelope
    set?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    disconnect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    delete?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    connect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    update?: InstructorAbsenceUpdateWithWhereUniqueWithoutInstructorInput | InstructorAbsenceUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: InstructorAbsenceUpdateManyWithWhereWithoutInstructorInput | InstructorAbsenceUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: InstructorAbsenceScalarWhereInput | InstructorAbsenceScalarWhereInput[]
  }

  export type InstructorScheduleUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput> | InstructorScheduleCreateWithoutInstructorInput[] | InstructorScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutInstructorInput | InstructorScheduleCreateOrConnectWithoutInstructorInput[]
    upsert?: InstructorScheduleUpsertWithWhereUniqueWithoutInstructorInput | InstructorScheduleUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: InstructorScheduleCreateManyInstructorInputEnvelope
    set?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    disconnect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    delete?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    connect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    update?: InstructorScheduleUpdateWithWhereUniqueWithoutInstructorInput | InstructorScheduleUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: InstructorScheduleUpdateManyWithWhereWithoutInstructorInput | InstructorScheduleUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: InstructorScheduleScalarWhereInput | InstructorScheduleScalarWhereInput[]
  }

  export type RecurringClassUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput> | RecurringClassCreateWithoutInstructorInput[] | RecurringClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutInstructorInput | RecurringClassCreateOrConnectWithoutInstructorInput[]
    upsert?: RecurringClassUpsertWithWhereUniqueWithoutInstructorInput | RecurringClassUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: RecurringClassCreateManyInstructorInputEnvelope
    set?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    disconnect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    delete?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    update?: RecurringClassUpdateWithWhereUniqueWithoutInstructorInput | RecurringClassUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: RecurringClassUpdateManyWithWhereWithoutInstructorInput | RecurringClassUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput> | ClassCreateWithoutInstructorInput[] | ClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutInstructorInput | ClassCreateOrConnectWithoutInstructorInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutInstructorInput | ClassUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: ClassCreateManyInstructorInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutInstructorInput | ClassUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutInstructorInput | ClassUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type InstructorAbsenceUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput> | InstructorAbsenceCreateWithoutInstructorInput[] | InstructorAbsenceUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorAbsenceCreateOrConnectWithoutInstructorInput | InstructorAbsenceCreateOrConnectWithoutInstructorInput[]
    upsert?: InstructorAbsenceUpsertWithWhereUniqueWithoutInstructorInput | InstructorAbsenceUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: InstructorAbsenceCreateManyInstructorInputEnvelope
    set?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    disconnect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    delete?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    connect?: InstructorAbsenceWhereUniqueInput | InstructorAbsenceWhereUniqueInput[]
    update?: InstructorAbsenceUpdateWithWhereUniqueWithoutInstructorInput | InstructorAbsenceUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: InstructorAbsenceUpdateManyWithWhereWithoutInstructorInput | InstructorAbsenceUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: InstructorAbsenceScalarWhereInput | InstructorAbsenceScalarWhereInput[]
  }

  export type InstructorScheduleUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput> | InstructorScheduleCreateWithoutInstructorInput[] | InstructorScheduleUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutInstructorInput | InstructorScheduleCreateOrConnectWithoutInstructorInput[]
    upsert?: InstructorScheduleUpsertWithWhereUniqueWithoutInstructorInput | InstructorScheduleUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: InstructorScheduleCreateManyInstructorInputEnvelope
    set?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    disconnect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    delete?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    connect?: InstructorScheduleWhereUniqueInput | InstructorScheduleWhereUniqueInput[]
    update?: InstructorScheduleUpdateWithWhereUniqueWithoutInstructorInput | InstructorScheduleUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: InstructorScheduleUpdateManyWithWhereWithoutInstructorInput | InstructorScheduleUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: InstructorScheduleScalarWhereInput | InstructorScheduleScalarWhereInput[]
  }

  export type RecurringClassUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput> | RecurringClassCreateWithoutInstructorInput[] | RecurringClassUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutInstructorInput | RecurringClassCreateOrConnectWithoutInstructorInput[]
    upsert?: RecurringClassUpsertWithWhereUniqueWithoutInstructorInput | RecurringClassUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: RecurringClassCreateManyInstructorInputEnvelope
    set?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    disconnect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    delete?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    update?: RecurringClassUpdateWithWhereUniqueWithoutInstructorInput | RecurringClassUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: RecurringClassUpdateManyWithWhereWithoutInstructorInput | RecurringClassUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
  }

  export type ChildCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput> | ChildCreateWithoutCustomerInput[] | ChildUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutCustomerInput | ChildCreateOrConnectWithoutCustomerInput[]
    createMany?: ChildCreateManyCustomerInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ClassCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput> | ClassCreateWithoutCustomerInput[] | ClassUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCustomerInput | ClassCreateOrConnectWithoutCustomerInput[]
    createMany?: ClassCreateManyCustomerInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ChildUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput> | ChildCreateWithoutCustomerInput[] | ChildUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutCustomerInput | ChildCreateOrConnectWithoutCustomerInput[]
    createMany?: ChildCreateManyCustomerInputEnvelope
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput> | ClassCreateWithoutCustomerInput[] | ClassUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCustomerInput | ClassCreateOrConnectWithoutCustomerInput[]
    createMany?: ClassCreateManyCustomerInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type ChildUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput> | ChildCreateWithoutCustomerInput[] | ChildUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutCustomerInput | ChildCreateOrConnectWithoutCustomerInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutCustomerInput | ChildUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ChildCreateManyCustomerInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutCustomerInput | ChildUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutCustomerInput | ChildUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ClassUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput> | ClassCreateWithoutCustomerInput[] | ClassUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCustomerInput | ClassCreateOrConnectWithoutCustomerInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutCustomerInput | ClassUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ClassCreateManyCustomerInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutCustomerInput | ClassUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutCustomerInput | ClassUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ChildUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput> | ChildCreateWithoutCustomerInput[] | ChildUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ChildCreateOrConnectWithoutCustomerInput | ChildCreateOrConnectWithoutCustomerInput[]
    upsert?: ChildUpsertWithWhereUniqueWithoutCustomerInput | ChildUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ChildCreateManyCustomerInputEnvelope
    set?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    disconnect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    delete?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    connect?: ChildWhereUniqueInput | ChildWhereUniqueInput[]
    update?: ChildUpdateWithWhereUniqueWithoutCustomerInput | ChildUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ChildUpdateManyWithWhereWithoutCustomerInput | ChildUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ChildScalarWhereInput | ChildScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput> | ClassCreateWithoutCustomerInput[] | ClassUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutCustomerInput | ClassCreateOrConnectWithoutCustomerInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutCustomerInput | ClassUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ClassCreateManyCustomerInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutCustomerInput | ClassUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutCustomerInput | ClassUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput> | SubscriptionCreateWithoutCustomerInput[] | SubscriptionUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCustomerInput | SubscriptionCreateOrConnectWithoutCustomerInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCustomerInput | SubscriptionUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SubscriptionCreateManyCustomerInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCustomerInput | SubscriptionUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCustomerInput | SubscriptionUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutClassesInput = {
    create?: XOR<CustomerCreateWithoutClassesInput, CustomerUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutClassesInput
    connect?: CustomerWhereUniqueInput
  }

  export type InstructorCreateNestedOneWithoutClassesInput = {
    create?: XOR<InstructorCreateWithoutClassesInput, InstructorUncheckedCreateWithoutClassesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutClassesInput
    connect?: InstructorWhereUniqueInput
  }

  export type RecurringClassCreateNestedOneWithoutClassesInput = {
    create?: XOR<RecurringClassCreateWithoutClassesInput, RecurringClassUncheckedCreateWithoutClassesInput>
    connectOrCreate?: RecurringClassCreateOrConnectWithoutClassesInput
    connect?: RecurringClassWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutClassInput = {
    create?: XOR<SubscriptionCreateWithoutClassInput, SubscriptionUncheckedCreateWithoutClassInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClassInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type ClassAttendanceCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput> | ClassAttendanceCreateWithoutClassInput[] | ClassAttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutClassInput | ClassAttendanceCreateOrConnectWithoutClassInput[]
    createMany?: ClassAttendanceCreateManyClassInputEnvelope
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
  }

  export type ClassAttendanceUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput> | ClassAttendanceCreateWithoutClassInput[] | ClassAttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutClassInput | ClassAttendanceCreateOrConnectWithoutClassInput[]
    createMany?: ClassAttendanceCreateManyClassInputEnvelope
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type CustomerUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<CustomerCreateWithoutClassesInput, CustomerUncheckedCreateWithoutClassesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutClassesInput
    upsert?: CustomerUpsertWithoutClassesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutClassesInput, CustomerUpdateWithoutClassesInput>, CustomerUncheckedUpdateWithoutClassesInput>
  }

  export type InstructorUpdateOneWithoutClassesNestedInput = {
    create?: XOR<InstructorCreateWithoutClassesInput, InstructorUncheckedCreateWithoutClassesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutClassesInput
    upsert?: InstructorUpsertWithoutClassesInput
    disconnect?: InstructorWhereInput | boolean
    delete?: InstructorWhereInput | boolean
    connect?: InstructorWhereUniqueInput
    update?: XOR<XOR<InstructorUpdateToOneWithWhereWithoutClassesInput, InstructorUpdateWithoutClassesInput>, InstructorUncheckedUpdateWithoutClassesInput>
  }

  export type RecurringClassUpdateOneWithoutClassesNestedInput = {
    create?: XOR<RecurringClassCreateWithoutClassesInput, RecurringClassUncheckedCreateWithoutClassesInput>
    connectOrCreate?: RecurringClassCreateOrConnectWithoutClassesInput
    upsert?: RecurringClassUpsertWithoutClassesInput
    disconnect?: RecurringClassWhereInput | boolean
    delete?: RecurringClassWhereInput | boolean
    connect?: RecurringClassWhereUniqueInput
    update?: XOR<XOR<RecurringClassUpdateToOneWithWhereWithoutClassesInput, RecurringClassUpdateWithoutClassesInput>, RecurringClassUncheckedUpdateWithoutClassesInput>
  }

  export type SubscriptionUpdateOneWithoutClassNestedInput = {
    create?: XOR<SubscriptionCreateWithoutClassInput, SubscriptionUncheckedCreateWithoutClassInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutClassInput
    upsert?: SubscriptionUpsertWithoutClassInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutClassInput, SubscriptionUpdateWithoutClassInput>, SubscriptionUncheckedUpdateWithoutClassInput>
  }

  export type ClassAttendanceUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput> | ClassAttendanceCreateWithoutClassInput[] | ClassAttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutClassInput | ClassAttendanceCreateOrConnectWithoutClassInput[]
    upsert?: ClassAttendanceUpsertWithWhereUniqueWithoutClassInput | ClassAttendanceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassAttendanceCreateManyClassInputEnvelope
    set?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    disconnect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    delete?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    update?: ClassAttendanceUpdateWithWhereUniqueWithoutClassInput | ClassAttendanceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassAttendanceUpdateManyWithWhereWithoutClassInput | ClassAttendanceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput> | ClassAttendanceCreateWithoutClassInput[] | ClassAttendanceUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutClassInput | ClassAttendanceCreateOrConnectWithoutClassInput[]
    upsert?: ClassAttendanceUpsertWithWhereUniqueWithoutClassInput | ClassAttendanceUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassAttendanceCreateManyClassInputEnvelope
    set?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    disconnect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    delete?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    update?: ClassAttendanceUpdateWithWhereUniqueWithoutClassInput | ClassAttendanceUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassAttendanceUpdateManyWithWhereWithoutClassInput | ClassAttendanceUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
  }

  export type ChildCreateNestedOneWithoutClassAttendanceInput = {
    create?: XOR<ChildCreateWithoutClassAttendanceInput, ChildUncheckedCreateWithoutClassAttendanceInput>
    connectOrCreate?: ChildCreateOrConnectWithoutClassAttendanceInput
    connect?: ChildWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutClassAttendanceInput = {
    create?: XOR<ClassCreateWithoutClassAttendanceInput, ClassUncheckedCreateWithoutClassAttendanceInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassAttendanceInput
    connect?: ClassWhereUniqueInput
  }

  export type ChildUpdateOneRequiredWithoutClassAttendanceNestedInput = {
    create?: XOR<ChildCreateWithoutClassAttendanceInput, ChildUncheckedCreateWithoutClassAttendanceInput>
    connectOrCreate?: ChildCreateOrConnectWithoutClassAttendanceInput
    upsert?: ChildUpsertWithoutClassAttendanceInput
    connect?: ChildWhereUniqueInput
    update?: XOR<XOR<ChildUpdateToOneWithWhereWithoutClassAttendanceInput, ChildUpdateWithoutClassAttendanceInput>, ChildUncheckedUpdateWithoutClassAttendanceInput>
  }

  export type ClassUpdateOneRequiredWithoutClassAttendanceNestedInput = {
    create?: XOR<ClassCreateWithoutClassAttendanceInput, ClassUncheckedCreateWithoutClassAttendanceInput>
    connectOrCreate?: ClassCreateOrConnectWithoutClassAttendanceInput
    upsert?: ClassUpsertWithoutClassAttendanceInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutClassAttendanceInput, ClassUpdateWithoutClassAttendanceInput>, ClassUncheckedUpdateWithoutClassAttendanceInput>
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type ClassCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput> | ClassCreateWithoutSubscriptionInput[] | ClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubscriptionInput | ClassCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ClassCreateManySubscriptionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type RecurringClassCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput> | RecurringClassCreateWithoutSubscriptionInput[] | RecurringClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutSubscriptionInput | RecurringClassCreateOrConnectWithoutSubscriptionInput[]
    createMany?: RecurringClassCreateManySubscriptionInputEnvelope
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
  }

  export type CustomerCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionInput
    connect?: CustomerWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
  }

  export type ClassUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput> | ClassCreateWithoutSubscriptionInput[] | ClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubscriptionInput | ClassCreateOrConnectWithoutSubscriptionInput[]
    createMany?: ClassCreateManySubscriptionInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type RecurringClassUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput> | RecurringClassCreateWithoutSubscriptionInput[] | RecurringClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutSubscriptionInput | RecurringClassCreateOrConnectWithoutSubscriptionInput[]
    createMany?: RecurringClassCreateManySubscriptionInputEnvelope
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput> | ClassCreateWithoutSubscriptionInput[] | ClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubscriptionInput | ClassCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSubscriptionInput | ClassUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ClassCreateManySubscriptionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSubscriptionInput | ClassUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSubscriptionInput | ClassUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type RecurringClassUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput> | RecurringClassCreateWithoutSubscriptionInput[] | RecurringClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutSubscriptionInput | RecurringClassCreateOrConnectWithoutSubscriptionInput[]
    upsert?: RecurringClassUpsertWithWhereUniqueWithoutSubscriptionInput | RecurringClassUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: RecurringClassCreateManySubscriptionInputEnvelope
    set?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    disconnect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    delete?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    update?: RecurringClassUpdateWithWhereUniqueWithoutSubscriptionInput | RecurringClassUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: RecurringClassUpdateManyWithWhereWithoutSubscriptionInput | RecurringClassUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
  }

  export type CustomerUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSubscriptionInput
    upsert?: CustomerUpsertWithoutSubscriptionInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSubscriptionInput, CustomerUpdateWithoutSubscriptionInput>, CustomerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionInput
    upsert?: PlanUpsertWithoutSubscriptionInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionInput, PlanUpdateWithoutSubscriptionInput>, PlanUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClassUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput> | ClassCreateWithoutSubscriptionInput[] | ClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutSubscriptionInput | ClassCreateOrConnectWithoutSubscriptionInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutSubscriptionInput | ClassUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: ClassCreateManySubscriptionInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutSubscriptionInput | ClassUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutSubscriptionInput | ClassUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type RecurringClassUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput> | RecurringClassCreateWithoutSubscriptionInput[] | RecurringClassUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: RecurringClassCreateOrConnectWithoutSubscriptionInput | RecurringClassCreateOrConnectWithoutSubscriptionInput[]
    upsert?: RecurringClassUpsertWithWhereUniqueWithoutSubscriptionInput | RecurringClassUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: RecurringClassCreateManySubscriptionInputEnvelope
    set?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    disconnect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    delete?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    connect?: RecurringClassWhereUniqueInput | RecurringClassWhereUniqueInput[]
    update?: RecurringClassUpdateWithWhereUniqueWithoutSubscriptionInput | RecurringClassUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: RecurringClassUpdateManyWithWhereWithoutSubscriptionInput | RecurringClassUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
  }

  export type ClassCreateNestedManyWithoutRecurringClassInput = {
    create?: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput> | ClassCreateWithoutRecurringClassInput[] | ClassUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutRecurringClassInput | ClassCreateOrConnectWithoutRecurringClassInput[]
    createMany?: ClassCreateManyRecurringClassInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type InstructorCreateNestedOneWithoutRecurringClassesInput = {
    create?: XOR<InstructorCreateWithoutRecurringClassesInput, InstructorUncheckedCreateWithoutRecurringClassesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutRecurringClassesInput
    connect?: InstructorWhereUniqueInput
  }

  export type SubscriptionCreateNestedOneWithoutRecurringClassInput = {
    create?: XOR<SubscriptionCreateWithoutRecurringClassInput, SubscriptionUncheckedCreateWithoutRecurringClassInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRecurringClassInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type RecurringClassAttendanceCreateNestedManyWithoutRecurringClassInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput> | RecurringClassAttendanceCreateWithoutRecurringClassInput[] | RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput | RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput[]
    createMany?: RecurringClassAttendanceCreateManyRecurringClassInputEnvelope
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
  }

  export type ClassUncheckedCreateNestedManyWithoutRecurringClassInput = {
    create?: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput> | ClassCreateWithoutRecurringClassInput[] | ClassUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutRecurringClassInput | ClassCreateOrConnectWithoutRecurringClassInput[]
    createMany?: ClassCreateManyRecurringClassInputEnvelope
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
  }

  export type RecurringClassAttendanceUncheckedCreateNestedManyWithoutRecurringClassInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput> | RecurringClassAttendanceCreateWithoutRecurringClassInput[] | RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput | RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput[]
    createMany?: RecurringClassAttendanceCreateManyRecurringClassInputEnvelope
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
  }

  export type ClassUpdateManyWithoutRecurringClassNestedInput = {
    create?: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput> | ClassCreateWithoutRecurringClassInput[] | ClassUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutRecurringClassInput | ClassCreateOrConnectWithoutRecurringClassInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutRecurringClassInput | ClassUpsertWithWhereUniqueWithoutRecurringClassInput[]
    createMany?: ClassCreateManyRecurringClassInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutRecurringClassInput | ClassUpdateWithWhereUniqueWithoutRecurringClassInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutRecurringClassInput | ClassUpdateManyWithWhereWithoutRecurringClassInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type InstructorUpdateOneWithoutRecurringClassesNestedInput = {
    create?: XOR<InstructorCreateWithoutRecurringClassesInput, InstructorUncheckedCreateWithoutRecurringClassesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutRecurringClassesInput
    upsert?: InstructorUpsertWithoutRecurringClassesInput
    disconnect?: InstructorWhereInput | boolean
    delete?: InstructorWhereInput | boolean
    connect?: InstructorWhereUniqueInput
    update?: XOR<XOR<InstructorUpdateToOneWithWhereWithoutRecurringClassesInput, InstructorUpdateWithoutRecurringClassesInput>, InstructorUncheckedUpdateWithoutRecurringClassesInput>
  }

  export type SubscriptionUpdateOneWithoutRecurringClassNestedInput = {
    create?: XOR<SubscriptionCreateWithoutRecurringClassInput, SubscriptionUncheckedCreateWithoutRecurringClassInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRecurringClassInput
    upsert?: SubscriptionUpsertWithoutRecurringClassInput
    disconnect?: SubscriptionWhereInput | boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutRecurringClassInput, SubscriptionUpdateWithoutRecurringClassInput>, SubscriptionUncheckedUpdateWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceUpdateManyWithoutRecurringClassNestedInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput> | RecurringClassAttendanceCreateWithoutRecurringClassInput[] | RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput | RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput[]
    upsert?: RecurringClassAttendanceUpsertWithWhereUniqueWithoutRecurringClassInput | RecurringClassAttendanceUpsertWithWhereUniqueWithoutRecurringClassInput[]
    createMany?: RecurringClassAttendanceCreateManyRecurringClassInputEnvelope
    set?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    disconnect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    delete?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    update?: RecurringClassAttendanceUpdateWithWhereUniqueWithoutRecurringClassInput | RecurringClassAttendanceUpdateWithWhereUniqueWithoutRecurringClassInput[]
    updateMany?: RecurringClassAttendanceUpdateManyWithWhereWithoutRecurringClassInput | RecurringClassAttendanceUpdateManyWithWhereWithoutRecurringClassInput[]
    deleteMany?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
  }

  export type ClassUncheckedUpdateManyWithoutRecurringClassNestedInput = {
    create?: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput> | ClassCreateWithoutRecurringClassInput[] | ClassUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: ClassCreateOrConnectWithoutRecurringClassInput | ClassCreateOrConnectWithoutRecurringClassInput[]
    upsert?: ClassUpsertWithWhereUniqueWithoutRecurringClassInput | ClassUpsertWithWhereUniqueWithoutRecurringClassInput[]
    createMany?: ClassCreateManyRecurringClassInputEnvelope
    set?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    disconnect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    delete?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    connect?: ClassWhereUniqueInput | ClassWhereUniqueInput[]
    update?: ClassUpdateWithWhereUniqueWithoutRecurringClassInput | ClassUpdateWithWhereUniqueWithoutRecurringClassInput[]
    updateMany?: ClassUpdateManyWithWhereWithoutRecurringClassInput | ClassUpdateManyWithWhereWithoutRecurringClassInput[]
    deleteMany?: ClassScalarWhereInput | ClassScalarWhereInput[]
  }

  export type RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassNestedInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput> | RecurringClassAttendanceCreateWithoutRecurringClassInput[] | RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput | RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput[]
    upsert?: RecurringClassAttendanceUpsertWithWhereUniqueWithoutRecurringClassInput | RecurringClassAttendanceUpsertWithWhereUniqueWithoutRecurringClassInput[]
    createMany?: RecurringClassAttendanceCreateManyRecurringClassInputEnvelope
    set?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    disconnect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    delete?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    update?: RecurringClassAttendanceUpdateWithWhereUniqueWithoutRecurringClassInput | RecurringClassAttendanceUpdateWithWhereUniqueWithoutRecurringClassInput[]
    updateMany?: RecurringClassAttendanceUpdateManyWithWhereWithoutRecurringClassInput | RecurringClassAttendanceUpdateManyWithWhereWithoutRecurringClassInput[]
    deleteMany?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
  }

  export type ChildCreateNestedOneWithoutRecurringClassAttendanceInput = {
    create?: XOR<ChildCreateWithoutRecurringClassAttendanceInput, ChildUncheckedCreateWithoutRecurringClassAttendanceInput>
    connectOrCreate?: ChildCreateOrConnectWithoutRecurringClassAttendanceInput
    connect?: ChildWhereUniqueInput
  }

  export type RecurringClassCreateNestedOneWithoutRecurringClassAttendanceInput = {
    create?: XOR<RecurringClassCreateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedCreateWithoutRecurringClassAttendanceInput>
    connectOrCreate?: RecurringClassCreateOrConnectWithoutRecurringClassAttendanceInput
    connect?: RecurringClassWhereUniqueInput
  }

  export type ChildUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput = {
    create?: XOR<ChildCreateWithoutRecurringClassAttendanceInput, ChildUncheckedCreateWithoutRecurringClassAttendanceInput>
    connectOrCreate?: ChildCreateOrConnectWithoutRecurringClassAttendanceInput
    upsert?: ChildUpsertWithoutRecurringClassAttendanceInput
    connect?: ChildWhereUniqueInput
    update?: XOR<XOR<ChildUpdateToOneWithWhereWithoutRecurringClassAttendanceInput, ChildUpdateWithoutRecurringClassAttendanceInput>, ChildUncheckedUpdateWithoutRecurringClassAttendanceInput>
  }

  export type RecurringClassUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput = {
    create?: XOR<RecurringClassCreateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedCreateWithoutRecurringClassAttendanceInput>
    connectOrCreate?: RecurringClassCreateOrConnectWithoutRecurringClassAttendanceInput
    upsert?: RecurringClassUpsertWithoutRecurringClassAttendanceInput
    connect?: RecurringClassWhereUniqueInput
    update?: XOR<XOR<RecurringClassUpdateToOneWithWhereWithoutRecurringClassAttendanceInput, RecurringClassUpdateWithoutRecurringClassAttendanceInput>, RecurringClassUncheckedUpdateWithoutRecurringClassAttendanceInput>
  }

  export type EventCreateNestedOneWithoutScheduleInput = {
    create?: XOR<EventCreateWithoutScheduleInput, EventUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: EventCreateOrConnectWithoutScheduleInput
    connect?: EventWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutScheduleNestedInput = {
    create?: XOR<EventCreateWithoutScheduleInput, EventUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: EventCreateOrConnectWithoutScheduleInput
    upsert?: EventUpsertWithoutScheduleInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutScheduleInput, EventUpdateWithoutScheduleInput>, EventUncheckedUpdateWithoutScheduleInput>
  }

  export type ScheduleCreateNestedManyWithoutEventInput = {
    create?: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput> | ScheduleCreateWithoutEventInput[] | ScheduleUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutEventInput | ScheduleCreateOrConnectWithoutEventInput[]
    createMany?: ScheduleCreateManyEventInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput> | ScheduleCreateWithoutEventInput[] | ScheduleUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutEventInput | ScheduleCreateOrConnectWithoutEventInput[]
    createMany?: ScheduleCreateManyEventInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleUpdateManyWithoutEventNestedInput = {
    create?: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput> | ScheduleCreateWithoutEventInput[] | ScheduleUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutEventInput | ScheduleCreateOrConnectWithoutEventInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutEventInput | ScheduleUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ScheduleCreateManyEventInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutEventInput | ScheduleUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutEventInput | ScheduleUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput> | ScheduleCreateWithoutEventInput[] | ScheduleUncheckedCreateWithoutEventInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutEventInput | ScheduleCreateOrConnectWithoutEventInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutEventInput | ScheduleUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: ScheduleCreateManyEventInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutEventInput | ScheduleUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutEventInput | ScheduleUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type InstructorCreateNestedOneWithoutInstructorSchedulesInput = {
    create?: XOR<InstructorCreateWithoutInstructorSchedulesInput, InstructorUncheckedCreateWithoutInstructorSchedulesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutInstructorSchedulesInput
    connect?: InstructorWhereUniqueInput
  }

  export type InstructorSlotCreateNestedManyWithoutScheduleInput = {
    create?: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput> | InstructorSlotCreateWithoutScheduleInput[] | InstructorSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: InstructorSlotCreateOrConnectWithoutScheduleInput | InstructorSlotCreateOrConnectWithoutScheduleInput[]
    createMany?: InstructorSlotCreateManyScheduleInputEnvelope
    connect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
  }

  export type InstructorSlotUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput> | InstructorSlotCreateWithoutScheduleInput[] | InstructorSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: InstructorSlotCreateOrConnectWithoutScheduleInput | InstructorSlotCreateOrConnectWithoutScheduleInput[]
    createMany?: InstructorSlotCreateManyScheduleInputEnvelope
    connect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
  }

  export type InstructorUpdateOneRequiredWithoutInstructorSchedulesNestedInput = {
    create?: XOR<InstructorCreateWithoutInstructorSchedulesInput, InstructorUncheckedCreateWithoutInstructorSchedulesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutInstructorSchedulesInput
    upsert?: InstructorUpsertWithoutInstructorSchedulesInput
    connect?: InstructorWhereUniqueInput
    update?: XOR<XOR<InstructorUpdateToOneWithWhereWithoutInstructorSchedulesInput, InstructorUpdateWithoutInstructorSchedulesInput>, InstructorUncheckedUpdateWithoutInstructorSchedulesInput>
  }

  export type InstructorSlotUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput> | InstructorSlotCreateWithoutScheduleInput[] | InstructorSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: InstructorSlotCreateOrConnectWithoutScheduleInput | InstructorSlotCreateOrConnectWithoutScheduleInput[]
    upsert?: InstructorSlotUpsertWithWhereUniqueWithoutScheduleInput | InstructorSlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: InstructorSlotCreateManyScheduleInputEnvelope
    set?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    disconnect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    delete?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    connect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    update?: InstructorSlotUpdateWithWhereUniqueWithoutScheduleInput | InstructorSlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: InstructorSlotUpdateManyWithWhereWithoutScheduleInput | InstructorSlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: InstructorSlotScalarWhereInput | InstructorSlotScalarWhereInput[]
  }

  export type InstructorSlotUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput> | InstructorSlotCreateWithoutScheduleInput[] | InstructorSlotUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: InstructorSlotCreateOrConnectWithoutScheduleInput | InstructorSlotCreateOrConnectWithoutScheduleInput[]
    upsert?: InstructorSlotUpsertWithWhereUniqueWithoutScheduleInput | InstructorSlotUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: InstructorSlotCreateManyScheduleInputEnvelope
    set?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    disconnect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    delete?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    connect?: InstructorSlotWhereUniqueInput | InstructorSlotWhereUniqueInput[]
    update?: InstructorSlotUpdateWithWhereUniqueWithoutScheduleInput | InstructorSlotUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: InstructorSlotUpdateManyWithWhereWithoutScheduleInput | InstructorSlotUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: InstructorSlotScalarWhereInput | InstructorSlotScalarWhereInput[]
  }

  export type InstructorScheduleCreateNestedOneWithoutSlotsInput = {
    create?: XOR<InstructorScheduleCreateWithoutSlotsInput, InstructorScheduleUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutSlotsInput
    connect?: InstructorScheduleWhereUniqueInput
  }

  export type InstructorScheduleUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<InstructorScheduleCreateWithoutSlotsInput, InstructorScheduleUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: InstructorScheduleCreateOrConnectWithoutSlotsInput
    upsert?: InstructorScheduleUpsertWithoutSlotsInput
    connect?: InstructorScheduleWhereUniqueInput
    update?: XOR<XOR<InstructorScheduleUpdateToOneWithWhereWithoutSlotsInput, InstructorScheduleUpdateWithoutSlotsInput>, InstructorScheduleUncheckedUpdateWithoutSlotsInput>
  }

  export type InstructorCreateNestedOneWithoutInstructorAbsencesInput = {
    create?: XOR<InstructorCreateWithoutInstructorAbsencesInput, InstructorUncheckedCreateWithoutInstructorAbsencesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutInstructorAbsencesInput
    connect?: InstructorWhereUniqueInput
  }

  export type InstructorUpdateOneRequiredWithoutInstructorAbsencesNestedInput = {
    create?: XOR<InstructorCreateWithoutInstructorAbsencesInput, InstructorUncheckedCreateWithoutInstructorAbsencesInput>
    connectOrCreate?: InstructorCreateOrConnectWithoutInstructorAbsencesInput
    upsert?: InstructorUpsertWithoutInstructorAbsencesInput
    connect?: InstructorWhereUniqueInput
    update?: XOR<XOR<InstructorUpdateToOneWithWhereWithoutInstructorAbsencesInput, InstructorUpdateWithoutInstructorAbsencesInput>, InstructorUncheckedUpdateWithoutInstructorAbsencesInput>
  }

  export type CustomerCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CustomerCreateWithoutChildrenInput, CustomerUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutChildrenInput
    connect?: CustomerWhereUniqueInput
  }

  export type ClassAttendanceCreateNestedManyWithoutChildrenInput = {
    create?: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput> | ClassAttendanceCreateWithoutChildrenInput[] | ClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutChildrenInput | ClassAttendanceCreateOrConnectWithoutChildrenInput[]
    createMany?: ClassAttendanceCreateManyChildrenInputEnvelope
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
  }

  export type RecurringClassAttendanceCreateNestedManyWithoutChildrenInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput> | RecurringClassAttendanceCreateWithoutChildrenInput[] | RecurringClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutChildrenInput | RecurringClassAttendanceCreateOrConnectWithoutChildrenInput[]
    createMany?: RecurringClassAttendanceCreateManyChildrenInputEnvelope
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
  }

  export type ClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput = {
    create?: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput> | ClassAttendanceCreateWithoutChildrenInput[] | ClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutChildrenInput | ClassAttendanceCreateOrConnectWithoutChildrenInput[]
    createMany?: ClassAttendanceCreateManyChildrenInputEnvelope
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
  }

  export type RecurringClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput> | RecurringClassAttendanceCreateWithoutChildrenInput[] | RecurringClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutChildrenInput | RecurringClassAttendanceCreateOrConnectWithoutChildrenInput[]
    createMany?: RecurringClassAttendanceCreateManyChildrenInputEnvelope
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CustomerUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<CustomerCreateWithoutChildrenInput, CustomerUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutChildrenInput
    upsert?: CustomerUpsertWithoutChildrenInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutChildrenInput, CustomerUpdateWithoutChildrenInput>, CustomerUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassAttendanceUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput> | ClassAttendanceCreateWithoutChildrenInput[] | ClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutChildrenInput | ClassAttendanceCreateOrConnectWithoutChildrenInput[]
    upsert?: ClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput | ClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput[]
    createMany?: ClassAttendanceCreateManyChildrenInputEnvelope
    set?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    disconnect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    delete?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    update?: ClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput | ClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: ClassAttendanceUpdateManyWithWhereWithoutChildrenInput | ClassAttendanceUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
  }

  export type RecurringClassAttendanceUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput> | RecurringClassAttendanceCreateWithoutChildrenInput[] | RecurringClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutChildrenInput | RecurringClassAttendanceCreateOrConnectWithoutChildrenInput[]
    upsert?: RecurringClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput | RecurringClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput[]
    createMany?: RecurringClassAttendanceCreateManyChildrenInputEnvelope
    set?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    disconnect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    delete?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    update?: RecurringClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput | RecurringClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: RecurringClassAttendanceUpdateManyWithWhereWithoutChildrenInput | RecurringClassAttendanceUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
  }

  export type ClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput> | ClassAttendanceCreateWithoutChildrenInput[] | ClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ClassAttendanceCreateOrConnectWithoutChildrenInput | ClassAttendanceCreateOrConnectWithoutChildrenInput[]
    upsert?: ClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput | ClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput[]
    createMany?: ClassAttendanceCreateManyChildrenInputEnvelope
    set?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    disconnect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    delete?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    connect?: ClassAttendanceWhereUniqueInput | ClassAttendanceWhereUniqueInput[]
    update?: ClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput | ClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: ClassAttendanceUpdateManyWithWhereWithoutChildrenInput | ClassAttendanceUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
  }

  export type RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput> | RecurringClassAttendanceCreateWithoutChildrenInput[] | RecurringClassAttendanceUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: RecurringClassAttendanceCreateOrConnectWithoutChildrenInput | RecurringClassAttendanceCreateOrConnectWithoutChildrenInput[]
    upsert?: RecurringClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput | RecurringClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput[]
    createMany?: RecurringClassAttendanceCreateManyChildrenInputEnvelope
    set?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    disconnect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    delete?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    connect?: RecurringClassAttendanceWhereUniqueInput | RecurringClassAttendanceWhereUniqueInput[]
    update?: RecurringClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput | RecurringClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: RecurringClassAttendanceUpdateManyWithWhereWithoutChildrenInput | RecurringClassAttendanceUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClassCreateWithoutInstructorInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    customer: CustomerCreateNestedOneWithoutClassesInput
    recurringClass?: RecurringClassCreateNestedOneWithoutClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutClassInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutInstructorInput = {
    id?: number
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutInstructorInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput>
  }

  export type ClassCreateManyInstructorInputEnvelope = {
    data: ClassCreateManyInstructorInput | ClassCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type InstructorAbsenceCreateWithoutInstructorInput = {
    absentAt: Date | string
  }

  export type InstructorAbsenceUncheckedCreateWithoutInstructorInput = {
    absentAt: Date | string
  }

  export type InstructorAbsenceCreateOrConnectWithoutInstructorInput = {
    where: InstructorAbsenceWhereUniqueInput
    create: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput>
  }

  export type InstructorAbsenceCreateManyInstructorInputEnvelope = {
    data: InstructorAbsenceCreateManyInstructorInput | InstructorAbsenceCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type InstructorScheduleCreateWithoutInstructorInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
    slots?: InstructorSlotCreateNestedManyWithoutScheduleInput
  }

  export type InstructorScheduleUncheckedCreateWithoutInstructorInput = {
    id?: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
    slots?: InstructorSlotUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type InstructorScheduleCreateOrConnectWithoutInstructorInput = {
    where: InstructorScheduleWhereUniqueInput
    create: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput>
  }

  export type InstructorScheduleCreateManyInstructorInputEnvelope = {
    data: InstructorScheduleCreateManyInstructorInput | InstructorScheduleCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type RecurringClassCreateWithoutInstructorInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassCreateNestedManyWithoutRecurringClassInput
    subscription?: SubscriptionCreateNestedOneWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassUncheckedCreateWithoutInstructorInput = {
    id?: number
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassUncheckedCreateNestedManyWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassCreateOrConnectWithoutInstructorInput = {
    where: RecurringClassWhereUniqueInput
    create: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput>
  }

  export type RecurringClassCreateManyInstructorInputEnvelope = {
    data: RecurringClassCreateManyInstructorInput | RecurringClassCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutInstructorInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutInstructorInput, ClassUncheckedUpdateWithoutInstructorInput>
    create: XOR<ClassCreateWithoutInstructorInput, ClassUncheckedCreateWithoutInstructorInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutInstructorInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutInstructorInput, ClassUncheckedUpdateWithoutInstructorInput>
  }

  export type ClassUpdateManyWithWhereWithoutInstructorInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutInstructorInput>
  }

  export type ClassScalarWhereInput = {
    AND?: ClassScalarWhereInput | ClassScalarWhereInput[]
    OR?: ClassScalarWhereInput[]
    NOT?: ClassScalarWhereInput | ClassScalarWhereInput[]
    id?: IntFilter<"Class"> | number
    instructorId?: IntNullableFilter<"Class"> | number | null
    customerId?: IntFilter<"Class"> | number
    recurringClassId?: IntNullableFilter<"Class"> | number | null
    dateTime?: DateTimeNullableFilter<"Class"> | Date | string | null
    status?: EnumStatusFilter<"Class"> | $Enums.Status
    subscriptionId?: IntNullableFilter<"Class"> | number | null
    rebookableUntil?: DateTimeNullableFilter<"Class"> | Date | string | null
    classCode?: StringFilter<"Class"> | string
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    isFreeTrial?: BoolFilter<"Class"> | boolean
  }

  export type InstructorAbsenceUpsertWithWhereUniqueWithoutInstructorInput = {
    where: InstructorAbsenceWhereUniqueInput
    update: XOR<InstructorAbsenceUpdateWithoutInstructorInput, InstructorAbsenceUncheckedUpdateWithoutInstructorInput>
    create: XOR<InstructorAbsenceCreateWithoutInstructorInput, InstructorAbsenceUncheckedCreateWithoutInstructorInput>
  }

  export type InstructorAbsenceUpdateWithWhereUniqueWithoutInstructorInput = {
    where: InstructorAbsenceWhereUniqueInput
    data: XOR<InstructorAbsenceUpdateWithoutInstructorInput, InstructorAbsenceUncheckedUpdateWithoutInstructorInput>
  }

  export type InstructorAbsenceUpdateManyWithWhereWithoutInstructorInput = {
    where: InstructorAbsenceScalarWhereInput
    data: XOR<InstructorAbsenceUpdateManyMutationInput, InstructorAbsenceUncheckedUpdateManyWithoutInstructorInput>
  }

  export type InstructorAbsenceScalarWhereInput = {
    AND?: InstructorAbsenceScalarWhereInput | InstructorAbsenceScalarWhereInput[]
    OR?: InstructorAbsenceScalarWhereInput[]
    NOT?: InstructorAbsenceScalarWhereInput | InstructorAbsenceScalarWhereInput[]
    instructorId?: IntFilter<"InstructorAbsence"> | number
    absentAt?: DateTimeFilter<"InstructorAbsence"> | Date | string
  }

  export type InstructorScheduleUpsertWithWhereUniqueWithoutInstructorInput = {
    where: InstructorScheduleWhereUniqueInput
    update: XOR<InstructorScheduleUpdateWithoutInstructorInput, InstructorScheduleUncheckedUpdateWithoutInstructorInput>
    create: XOR<InstructorScheduleCreateWithoutInstructorInput, InstructorScheduleUncheckedCreateWithoutInstructorInput>
  }

  export type InstructorScheduleUpdateWithWhereUniqueWithoutInstructorInput = {
    where: InstructorScheduleWhereUniqueInput
    data: XOR<InstructorScheduleUpdateWithoutInstructorInput, InstructorScheduleUncheckedUpdateWithoutInstructorInput>
  }

  export type InstructorScheduleUpdateManyWithWhereWithoutInstructorInput = {
    where: InstructorScheduleScalarWhereInput
    data: XOR<InstructorScheduleUpdateManyMutationInput, InstructorScheduleUncheckedUpdateManyWithoutInstructorInput>
  }

  export type InstructorScheduleScalarWhereInput = {
    AND?: InstructorScheduleScalarWhereInput | InstructorScheduleScalarWhereInput[]
    OR?: InstructorScheduleScalarWhereInput[]
    NOT?: InstructorScheduleScalarWhereInput | InstructorScheduleScalarWhereInput[]
    id?: IntFilter<"InstructorSchedule"> | number
    instructorId?: IntFilter<"InstructorSchedule"> | number
    effectiveFrom?: DateTimeFilter<"InstructorSchedule"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"InstructorSchedule"> | Date | string | null
    timezone?: StringFilter<"InstructorSchedule"> | string
  }

  export type RecurringClassUpsertWithWhereUniqueWithoutInstructorInput = {
    where: RecurringClassWhereUniqueInput
    update: XOR<RecurringClassUpdateWithoutInstructorInput, RecurringClassUncheckedUpdateWithoutInstructorInput>
    create: XOR<RecurringClassCreateWithoutInstructorInput, RecurringClassUncheckedCreateWithoutInstructorInput>
  }

  export type RecurringClassUpdateWithWhereUniqueWithoutInstructorInput = {
    where: RecurringClassWhereUniqueInput
    data: XOR<RecurringClassUpdateWithoutInstructorInput, RecurringClassUncheckedUpdateWithoutInstructorInput>
  }

  export type RecurringClassUpdateManyWithWhereWithoutInstructorInput = {
    where: RecurringClassScalarWhereInput
    data: XOR<RecurringClassUpdateManyMutationInput, RecurringClassUncheckedUpdateManyWithoutInstructorInput>
  }

  export type RecurringClassScalarWhereInput = {
    AND?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
    OR?: RecurringClassScalarWhereInput[]
    NOT?: RecurringClassScalarWhereInput | RecurringClassScalarWhereInput[]
    id?: IntFilter<"RecurringClass"> | number
    instructorId?: IntNullableFilter<"RecurringClass"> | number | null
    subscriptionId?: IntNullableFilter<"RecurringClass"> | number | null
    startAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
    endAt?: DateTimeNullableFilter<"RecurringClass"> | Date | string | null
  }

  export type ChildCreateWithoutCustomerInput = {
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classAttendance?: ClassAttendanceCreateNestedManyWithoutChildrenInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutCustomerInput = {
    id?: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
  }

  export type ChildCreateOrConnectWithoutCustomerInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput>
  }

  export type ChildCreateManyCustomerInputEnvelope = {
    data: ChildCreateManyCustomerInput | ChildCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ClassCreateWithoutCustomerInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    instructor?: InstructorCreateNestedOneWithoutClassesInput
    recurringClass?: RecurringClassCreateNestedOneWithoutClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutClassInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutCustomerInput = {
    id?: number
    instructorId?: number | null
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutCustomerInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput>
  }

  export type ClassCreateManyCustomerInputEnvelope = {
    data: ClassCreateManyCustomerInput | ClassCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutCustomerInput = {
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassCreateNestedManyWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCustomerInput = {
    id?: number
    planId: number
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassUncheckedCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionCreateManyCustomerInputEnvelope = {
    data: SubscriptionCreateManyCustomerInput | SubscriptionCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ChildUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ChildWhereUniqueInput
    update: XOR<ChildUpdateWithoutCustomerInput, ChildUncheckedUpdateWithoutCustomerInput>
    create: XOR<ChildCreateWithoutCustomerInput, ChildUncheckedCreateWithoutCustomerInput>
  }

  export type ChildUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ChildWhereUniqueInput
    data: XOR<ChildUpdateWithoutCustomerInput, ChildUncheckedUpdateWithoutCustomerInput>
  }

  export type ChildUpdateManyWithWhereWithoutCustomerInput = {
    where: ChildScalarWhereInput
    data: XOR<ChildUpdateManyMutationInput, ChildUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ChildScalarWhereInput = {
    AND?: ChildScalarWhereInput | ChildScalarWhereInput[]
    OR?: ChildScalarWhereInput[]
    NOT?: ChildScalarWhereInput | ChildScalarWhereInput[]
    id?: IntFilter<"Child"> | number
    customerId?: IntFilter<"Child"> | number
    name?: StringFilter<"Child"> | string
    birthdate?: DateTimeNullableFilter<"Child"> | Date | string | null
    personalInfo?: StringNullableFilter<"Child"> | string | null
    createdAt?: DateTimeFilter<"Child"> | Date | string
    updatedAt?: DateTimeFilter<"Child"> | Date | string
  }

  export type ClassUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutCustomerInput, ClassUncheckedUpdateWithoutCustomerInput>
    create: XOR<ClassCreateWithoutCustomerInput, ClassUncheckedCreateWithoutCustomerInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutCustomerInput, ClassUncheckedUpdateWithoutCustomerInput>
  }

  export type ClassUpdateManyWithWhereWithoutCustomerInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
    create: XOR<SubscriptionCreateWithoutCustomerInput, SubscriptionUncheckedCreateWithoutCustomerInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCustomerInput, SubscriptionUncheckedUpdateWithoutCustomerInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCustomerInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: IntFilter<"Subscription"> | number
    planId?: IntFilter<"Subscription"> | number
    customerId?: IntFilter<"Subscription"> | number
    startAt?: DateTimeFilter<"Subscription"> | Date | string
    endAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
  }

  export type CustomerCreateWithoutClassesInput = {
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutClassesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutClassesInput, CustomerUncheckedCreateWithoutClassesInput>
  }

  export type InstructorCreateWithoutClassesInput = {
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    instructorAbsences?: InstructorAbsenceCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    instructorAbsences?: InstructorAbsenceUncheckedCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleUncheckedCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type InstructorCreateOrConnectWithoutClassesInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutClassesInput, InstructorUncheckedCreateWithoutClassesInput>
  }

  export type RecurringClassCreateWithoutClassesInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    instructor?: InstructorCreateNestedOneWithoutRecurringClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassUncheckedCreateWithoutClassesInput = {
    id?: number
    instructorId?: number | null
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassCreateOrConnectWithoutClassesInput = {
    where: RecurringClassWhereUniqueInput
    create: XOR<RecurringClassCreateWithoutClassesInput, RecurringClassUncheckedCreateWithoutClassesInput>
  }

  export type SubscriptionCreateWithoutClassInput = {
    startAt: Date | string
    endAt?: Date | string | null
    recurringClass?: RecurringClassCreateNestedManyWithoutSubscriptionInput
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutClassInput = {
    id?: number
    planId: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
    recurringClass?: RecurringClassUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutClassInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutClassInput, SubscriptionUncheckedCreateWithoutClassInput>
  }

  export type ClassAttendanceCreateWithoutClassInput = {
    children: ChildCreateNestedOneWithoutClassAttendanceInput
  }

  export type ClassAttendanceUncheckedCreateWithoutClassInput = {
    childrenId: number
  }

  export type ClassAttendanceCreateOrConnectWithoutClassInput = {
    where: ClassAttendanceWhereUniqueInput
    create: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput>
  }

  export type ClassAttendanceCreateManyClassInputEnvelope = {
    data: ClassAttendanceCreateManyClassInput | ClassAttendanceCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutClassesInput = {
    update: XOR<CustomerUpdateWithoutClassesInput, CustomerUncheckedUpdateWithoutClassesInput>
    create: XOR<CustomerCreateWithoutClassesInput, CustomerUncheckedCreateWithoutClassesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutClassesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutClassesInput, CustomerUncheckedUpdateWithoutClassesInput>
  }

  export type CustomerUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type InstructorUpsertWithoutClassesInput = {
    update: XOR<InstructorUpdateWithoutClassesInput, InstructorUncheckedUpdateWithoutClassesInput>
    create: XOR<InstructorCreateWithoutClassesInput, InstructorUncheckedCreateWithoutClassesInput>
    where?: InstructorWhereInput
  }

  export type InstructorUpdateToOneWithWhereWithoutClassesInput = {
    where?: InstructorWhereInput
    data: XOR<InstructorUpdateWithoutClassesInput, InstructorUncheckedUpdateWithoutClassesInput>
  }

  export type InstructorUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    instructorAbsences?: InstructorAbsenceUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    instructorAbsences?: InstructorAbsenceUncheckedUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type RecurringClassUpsertWithoutClassesInput = {
    update: XOR<RecurringClassUpdateWithoutClassesInput, RecurringClassUncheckedUpdateWithoutClassesInput>
    create: XOR<RecurringClassCreateWithoutClassesInput, RecurringClassUncheckedCreateWithoutClassesInput>
    where?: RecurringClassWhereInput
  }

  export type RecurringClassUpdateToOneWithWhereWithoutClassesInput = {
    where?: RecurringClassWhereInput
    data: XOR<RecurringClassUpdateWithoutClassesInput, RecurringClassUncheckedUpdateWithoutClassesInput>
  }

  export type RecurringClassUpdateWithoutClassesInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instructor?: InstructorUpdateOneWithoutRecurringClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassNestedInput
  }

  export type SubscriptionUpsertWithoutClassInput = {
    update: XOR<SubscriptionUpdateWithoutClassInput, SubscriptionUncheckedUpdateWithoutClassInput>
    create: XOR<SubscriptionCreateWithoutClassInput, SubscriptionUncheckedCreateWithoutClassInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutClassInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutClassInput, SubscriptionUncheckedUpdateWithoutClassInput>
  }

  export type SubscriptionUpdateWithoutClassInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringClass?: RecurringClassUpdateManyWithoutSubscriptionNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurringClass?: RecurringClassUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type ClassAttendanceUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassAttendanceWhereUniqueInput
    update: XOR<ClassAttendanceUpdateWithoutClassInput, ClassAttendanceUncheckedUpdateWithoutClassInput>
    create: XOR<ClassAttendanceCreateWithoutClassInput, ClassAttendanceUncheckedCreateWithoutClassInput>
  }

  export type ClassAttendanceUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassAttendanceWhereUniqueInput
    data: XOR<ClassAttendanceUpdateWithoutClassInput, ClassAttendanceUncheckedUpdateWithoutClassInput>
  }

  export type ClassAttendanceUpdateManyWithWhereWithoutClassInput = {
    where: ClassAttendanceScalarWhereInput
    data: XOR<ClassAttendanceUpdateManyMutationInput, ClassAttendanceUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassAttendanceScalarWhereInput = {
    AND?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
    OR?: ClassAttendanceScalarWhereInput[]
    NOT?: ClassAttendanceScalarWhereInput | ClassAttendanceScalarWhereInput[]
    classId?: IntFilter<"ClassAttendance"> | number
    childrenId?: IntFilter<"ClassAttendance"> | number
  }

  export type ChildCreateWithoutClassAttendanceInput = {
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutChildrenInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutClassAttendanceInput = {
    id?: number
    customerId: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
  }

  export type ChildCreateOrConnectWithoutClassAttendanceInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutClassAttendanceInput, ChildUncheckedCreateWithoutClassAttendanceInput>
  }

  export type ClassCreateWithoutClassAttendanceInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    customer: CustomerCreateNestedOneWithoutClassesInput
    instructor?: InstructorCreateNestedOneWithoutClassesInput
    recurringClass?: RecurringClassCreateNestedOneWithoutClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutClassAttendanceInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type ClassCreateOrConnectWithoutClassAttendanceInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutClassAttendanceInput, ClassUncheckedCreateWithoutClassAttendanceInput>
  }

  export type ChildUpsertWithoutClassAttendanceInput = {
    update: XOR<ChildUpdateWithoutClassAttendanceInput, ChildUncheckedUpdateWithoutClassAttendanceInput>
    create: XOR<ChildCreateWithoutClassAttendanceInput, ChildUncheckedCreateWithoutClassAttendanceInput>
    where?: ChildWhereInput
  }

  export type ChildUpdateToOneWithWhereWithoutClassAttendanceInput = {
    where?: ChildWhereInput
    data: XOR<ChildUpdateWithoutClassAttendanceInput, ChildUncheckedUpdateWithoutClassAttendanceInput>
  }

  export type ChildUpdateWithoutClassAttendanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutChildrenNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutClassAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
  }

  export type ClassUpsertWithoutClassAttendanceInput = {
    update: XOR<ClassUpdateWithoutClassAttendanceInput, ClassUncheckedUpdateWithoutClassAttendanceInput>
    create: XOR<ClassCreateWithoutClassAttendanceInput, ClassUncheckedCreateWithoutClassAttendanceInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutClassAttendanceInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutClassAttendanceInput, ClassUncheckedUpdateWithoutClassAttendanceInput>
  }

  export type ClassUpdateWithoutClassAttendanceInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutClassesNestedInput
    instructor?: InstructorUpdateOneWithoutClassesNestedInput
    recurringClass?: RecurringClassUpdateOneWithoutClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutClassAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassCreateNestedManyWithoutSubscriptionInput
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassUncheckedCreateNestedManyWithoutSubscriptionInput
    recurringClass?: RecurringClassUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type ClassCreateWithoutSubscriptionInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    customer: CustomerCreateNestedOneWithoutClassesInput
    instructor?: InstructorCreateNestedOneWithoutClassesInput
    recurringClass?: RecurringClassCreateNestedOneWithoutClassesInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubscriptionInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClassCreateManySubscriptionInputEnvelope = {
    data: ClassCreateManySubscriptionInput | ClassCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type RecurringClassCreateWithoutSubscriptionInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassCreateNestedManyWithoutRecurringClassInput
    instructor?: InstructorCreateNestedOneWithoutRecurringClassesInput
    recurringClassAttendance?: RecurringClassAttendanceCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    instructorId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassUncheckedCreateNestedManyWithoutRecurringClassInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassCreateOrConnectWithoutSubscriptionInput = {
    where: RecurringClassWhereUniqueInput
    create: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput>
  }

  export type RecurringClassCreateManySubscriptionInputEnvelope = {
    data: RecurringClassCreateManySubscriptionInput | RecurringClassCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutSubscriptionInput = {
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildCreateNestedManyWithoutCustomerInput
    classes?: ClassCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    children?: ChildUncheckedCreateNestedManyWithoutCustomerInput
    classes?: ClassUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSubscriptionInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
  }

  export type PlanCreateWithoutSubscriptionInput = {
    name: string
    description: string
    weeklyClassTimes: number
    createdAt?: Date | string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
  }

  export type PlanUncheckedCreateWithoutSubscriptionInput = {
    id?: number
    name: string
    description: string
    weeklyClassTimes: number
    createdAt?: Date | string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
  }

  export type PlanCreateOrConnectWithoutSubscriptionInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClassUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutSubscriptionInput, ClassUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<ClassCreateWithoutSubscriptionInput, ClassUncheckedCreateWithoutSubscriptionInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutSubscriptionInput, ClassUncheckedUpdateWithoutSubscriptionInput>
  }

  export type ClassUpdateManyWithWhereWithoutSubscriptionInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type RecurringClassUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: RecurringClassWhereUniqueInput
    update: XOR<RecurringClassUpdateWithoutSubscriptionInput, RecurringClassUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<RecurringClassCreateWithoutSubscriptionInput, RecurringClassUncheckedCreateWithoutSubscriptionInput>
  }

  export type RecurringClassUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: RecurringClassWhereUniqueInput
    data: XOR<RecurringClassUpdateWithoutSubscriptionInput, RecurringClassUncheckedUpdateWithoutSubscriptionInput>
  }

  export type RecurringClassUpdateManyWithWhereWithoutSubscriptionInput = {
    where: RecurringClassScalarWhereInput
    data: XOR<RecurringClassUpdateManyMutationInput, RecurringClassUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type CustomerUpsertWithoutSubscriptionInput = {
    update: XOR<CustomerUpdateWithoutSubscriptionInput, CustomerUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<CustomerCreateWithoutSubscriptionInput, CustomerUncheckedCreateWithoutSubscriptionInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSubscriptionInput, CustomerUncheckedUpdateWithoutSubscriptionInput>
  }

  export type CustomerUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUpdateManyWithoutCustomerNestedInput
    classes?: ClassUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: ChildUncheckedUpdateManyWithoutCustomerNestedInput
    classes?: ClassUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type PlanUpsertWithoutSubscriptionInput = {
    update: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PlanCreateWithoutSubscriptionInput, PlanUncheckedCreateWithoutSubscriptionInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionInput, PlanUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PlanUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlanUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    weeklyClassTimes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassCreateWithoutRecurringClassInput = {
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    customer: CustomerCreateNestedOneWithoutClassesInput
    instructor?: InstructorCreateNestedOneWithoutClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutClassInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutRecurringClassInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutRecurringClassInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput>
  }

  export type ClassCreateManyRecurringClassInputEnvelope = {
    data: ClassCreateManyRecurringClassInput | ClassCreateManyRecurringClassInput[]
    skipDuplicates?: boolean
  }

  export type InstructorCreateWithoutRecurringClassesInput = {
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutRecurringClassesInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassUncheckedCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceUncheckedCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type InstructorCreateOrConnectWithoutRecurringClassesInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutRecurringClassesInput, InstructorUncheckedCreateWithoutRecurringClassesInput>
  }

  export type SubscriptionCreateWithoutRecurringClassInput = {
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassCreateNestedManyWithoutSubscriptionInput
    customer: CustomerCreateNestedOneWithoutSubscriptionInput
    plan: PlanCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutRecurringClassInput = {
    id?: number
    planId: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
    class?: ClassUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutRecurringClassInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutRecurringClassInput, SubscriptionUncheckedCreateWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceCreateWithoutRecurringClassInput = {
    children: ChildCreateNestedOneWithoutRecurringClassAttendanceInput
  }

  export type RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput = {
    childrenId: number
  }

  export type RecurringClassAttendanceCreateOrConnectWithoutRecurringClassInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    create: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceCreateManyRecurringClassInputEnvelope = {
    data: RecurringClassAttendanceCreateManyRecurringClassInput | RecurringClassAttendanceCreateManyRecurringClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassUpsertWithWhereUniqueWithoutRecurringClassInput = {
    where: ClassWhereUniqueInput
    update: XOR<ClassUpdateWithoutRecurringClassInput, ClassUncheckedUpdateWithoutRecurringClassInput>
    create: XOR<ClassCreateWithoutRecurringClassInput, ClassUncheckedCreateWithoutRecurringClassInput>
  }

  export type ClassUpdateWithWhereUniqueWithoutRecurringClassInput = {
    where: ClassWhereUniqueInput
    data: XOR<ClassUpdateWithoutRecurringClassInput, ClassUncheckedUpdateWithoutRecurringClassInput>
  }

  export type ClassUpdateManyWithWhereWithoutRecurringClassInput = {
    where: ClassScalarWhereInput
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyWithoutRecurringClassInput>
  }

  export type InstructorUpsertWithoutRecurringClassesInput = {
    update: XOR<InstructorUpdateWithoutRecurringClassesInput, InstructorUncheckedUpdateWithoutRecurringClassesInput>
    create: XOR<InstructorCreateWithoutRecurringClassesInput, InstructorUncheckedCreateWithoutRecurringClassesInput>
    where?: InstructorWhereInput
  }

  export type InstructorUpdateToOneWithWhereWithoutRecurringClassesInput = {
    where?: InstructorWhereInput
    data: XOR<InstructorUpdateWithoutRecurringClassesInput, InstructorUncheckedUpdateWithoutRecurringClassesInput>
  }

  export type InstructorUpdateWithoutRecurringClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutRecurringClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUncheckedUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUncheckedUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type SubscriptionUpsertWithoutRecurringClassInput = {
    update: XOR<SubscriptionUpdateWithoutRecurringClassInput, SubscriptionUncheckedUpdateWithoutRecurringClassInput>
    create: XOR<SubscriptionCreateWithoutRecurringClassInput, SubscriptionUncheckedCreateWithoutRecurringClassInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutRecurringClassInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutRecurringClassInput, SubscriptionUncheckedUpdateWithoutRecurringClassInput>
  }

  export type SubscriptionUpdateWithoutRecurringClassInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUpdateManyWithoutSubscriptionNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutRecurringClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type RecurringClassAttendanceUpsertWithWhereUniqueWithoutRecurringClassInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    update: XOR<RecurringClassAttendanceUpdateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedUpdateWithoutRecurringClassInput>
    create: XOR<RecurringClassAttendanceCreateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedCreateWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceUpdateWithWhereUniqueWithoutRecurringClassInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    data: XOR<RecurringClassAttendanceUpdateWithoutRecurringClassInput, RecurringClassAttendanceUncheckedUpdateWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceUpdateManyWithWhereWithoutRecurringClassInput = {
    where: RecurringClassAttendanceScalarWhereInput
    data: XOR<RecurringClassAttendanceUpdateManyMutationInput, RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassInput>
  }

  export type RecurringClassAttendanceScalarWhereInput = {
    AND?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
    OR?: RecurringClassAttendanceScalarWhereInput[]
    NOT?: RecurringClassAttendanceScalarWhereInput | RecurringClassAttendanceScalarWhereInput[]
    recurringClassId?: IntFilter<"RecurringClassAttendance"> | number
    childrenId?: IntFilter<"RecurringClassAttendance"> | number
  }

  export type ChildCreateWithoutRecurringClassAttendanceInput = {
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutChildrenInput
    classAttendance?: ClassAttendanceCreateNestedManyWithoutChildrenInput
  }

  export type ChildUncheckedCreateWithoutRecurringClassAttendanceInput = {
    id?: number
    customerId: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classAttendance?: ClassAttendanceUncheckedCreateNestedManyWithoutChildrenInput
  }

  export type ChildCreateOrConnectWithoutRecurringClassAttendanceInput = {
    where: ChildWhereUniqueInput
    create: XOR<ChildCreateWithoutRecurringClassAttendanceInput, ChildUncheckedCreateWithoutRecurringClassAttendanceInput>
  }

  export type RecurringClassCreateWithoutRecurringClassAttendanceInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassCreateNestedManyWithoutRecurringClassInput
    instructor?: InstructorCreateNestedOneWithoutRecurringClassesInput
    subscription?: SubscriptionCreateNestedOneWithoutRecurringClassInput
  }

  export type RecurringClassUncheckedCreateWithoutRecurringClassAttendanceInput = {
    id?: number
    instructorId?: number | null
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    classes?: ClassUncheckedCreateNestedManyWithoutRecurringClassInput
  }

  export type RecurringClassCreateOrConnectWithoutRecurringClassAttendanceInput = {
    where: RecurringClassWhereUniqueInput
    create: XOR<RecurringClassCreateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedCreateWithoutRecurringClassAttendanceInput>
  }

  export type ChildUpsertWithoutRecurringClassAttendanceInput = {
    update: XOR<ChildUpdateWithoutRecurringClassAttendanceInput, ChildUncheckedUpdateWithoutRecurringClassAttendanceInput>
    create: XOR<ChildCreateWithoutRecurringClassAttendanceInput, ChildUncheckedCreateWithoutRecurringClassAttendanceInput>
    where?: ChildWhereInput
  }

  export type ChildUpdateToOneWithWhereWithoutRecurringClassAttendanceInput = {
    where?: ChildWhereInput
    data: XOR<ChildUpdateWithoutRecurringClassAttendanceInput, ChildUncheckedUpdateWithoutRecurringClassAttendanceInput>
  }

  export type ChildUpdateWithoutRecurringClassAttendanceInput = {
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutChildrenNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutRecurringClassAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
  }

  export type RecurringClassUpsertWithoutRecurringClassAttendanceInput = {
    update: XOR<RecurringClassUpdateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedUpdateWithoutRecurringClassAttendanceInput>
    create: XOR<RecurringClassCreateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedCreateWithoutRecurringClassAttendanceInput>
    where?: RecurringClassWhereInput
  }

  export type RecurringClassUpdateToOneWithWhereWithoutRecurringClassAttendanceInput = {
    where?: RecurringClassWhereInput
    data: XOR<RecurringClassUpdateWithoutRecurringClassAttendanceInput, RecurringClassUncheckedUpdateWithoutRecurringClassAttendanceInput>
  }

  export type RecurringClassUpdateWithoutRecurringClassAttendanceInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUpdateManyWithoutRecurringClassNestedInput
    instructor?: InstructorUpdateOneWithoutRecurringClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateWithoutRecurringClassAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUncheckedUpdateManyWithoutRecurringClassNestedInput
  }

  export type EventCreateWithoutScheduleInput = {
    name: string
    color: string
  }

  export type EventUncheckedCreateWithoutScheduleInput = {
    id?: number
    name: string
    color: string
  }

  export type EventCreateOrConnectWithoutScheduleInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutScheduleInput, EventUncheckedCreateWithoutScheduleInput>
  }

  export type EventUpsertWithoutScheduleInput = {
    update: XOR<EventUpdateWithoutScheduleInput, EventUncheckedUpdateWithoutScheduleInput>
    create: XOR<EventCreateWithoutScheduleInput, EventUncheckedCreateWithoutScheduleInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutScheduleInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutScheduleInput, EventUncheckedUpdateWithoutScheduleInput>
  }

  export type EventUpdateWithoutScheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type EventUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleCreateWithoutEventInput = {
    date: Date | string
  }

  export type ScheduleUncheckedCreateWithoutEventInput = {
    id?: number
    date: Date | string
  }

  export type ScheduleCreateOrConnectWithoutEventInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput>
  }

  export type ScheduleCreateManyEventInputEnvelope = {
    data: ScheduleCreateManyEventInput | ScheduleCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleUpsertWithWhereUniqueWithoutEventInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutEventInput, ScheduleUncheckedUpdateWithoutEventInput>
    create: XOR<ScheduleCreateWithoutEventInput, ScheduleUncheckedCreateWithoutEventInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutEventInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutEventInput, ScheduleUncheckedUpdateWithoutEventInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutEventInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutEventInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: IntFilter<"Schedule"> | number
    date?: DateTimeFilter<"Schedule"> | Date | string
    eventId?: IntFilter<"Schedule"> | number
  }

  export type InstructorCreateWithoutInstructorSchedulesInput = {
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutInstructorSchedulesInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassUncheckedCreateNestedManyWithoutInstructorInput
    instructorAbsences?: InstructorAbsenceUncheckedCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type InstructorCreateOrConnectWithoutInstructorSchedulesInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutInstructorSchedulesInput, InstructorUncheckedCreateWithoutInstructorSchedulesInput>
  }

  export type InstructorSlotCreateWithoutScheduleInput = {
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotUncheckedCreateWithoutScheduleInput = {
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotCreateOrConnectWithoutScheduleInput = {
    where: InstructorSlotWhereUniqueInput
    create: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput>
  }

  export type InstructorSlotCreateManyScheduleInputEnvelope = {
    data: InstructorSlotCreateManyScheduleInput | InstructorSlotCreateManyScheduleInput[]
    skipDuplicates?: boolean
  }

  export type InstructorUpsertWithoutInstructorSchedulesInput = {
    update: XOR<InstructorUpdateWithoutInstructorSchedulesInput, InstructorUncheckedUpdateWithoutInstructorSchedulesInput>
    create: XOR<InstructorCreateWithoutInstructorSchedulesInput, InstructorUncheckedCreateWithoutInstructorSchedulesInput>
    where?: InstructorWhereInput
  }

  export type InstructorUpdateToOneWithWhereWithoutInstructorSchedulesInput = {
    where?: InstructorWhereInput
    data: XOR<InstructorUpdateWithoutInstructorSchedulesInput, InstructorUncheckedUpdateWithoutInstructorSchedulesInput>
  }

  export type InstructorUpdateWithoutInstructorSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutInstructorSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUncheckedUpdateManyWithoutInstructorNestedInput
    instructorAbsences?: InstructorAbsenceUncheckedUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorSlotUpsertWithWhereUniqueWithoutScheduleInput = {
    where: InstructorSlotWhereUniqueInput
    update: XOR<InstructorSlotUpdateWithoutScheduleInput, InstructorSlotUncheckedUpdateWithoutScheduleInput>
    create: XOR<InstructorSlotCreateWithoutScheduleInput, InstructorSlotUncheckedCreateWithoutScheduleInput>
  }

  export type InstructorSlotUpdateWithWhereUniqueWithoutScheduleInput = {
    where: InstructorSlotWhereUniqueInput
    data: XOR<InstructorSlotUpdateWithoutScheduleInput, InstructorSlotUncheckedUpdateWithoutScheduleInput>
  }

  export type InstructorSlotUpdateManyWithWhereWithoutScheduleInput = {
    where: InstructorSlotScalarWhereInput
    data: XOR<InstructorSlotUpdateManyMutationInput, InstructorSlotUncheckedUpdateManyWithoutScheduleInput>
  }

  export type InstructorSlotScalarWhereInput = {
    AND?: InstructorSlotScalarWhereInput | InstructorSlotScalarWhereInput[]
    OR?: InstructorSlotScalarWhereInput[]
    NOT?: InstructorSlotScalarWhereInput | InstructorSlotScalarWhereInput[]
    scheduleId?: IntFilter<"InstructorSlot"> | number
    weekday?: IntFilter<"InstructorSlot"> | number
    startTime?: DateTimeFilter<"InstructorSlot"> | Date | string
  }

  export type InstructorScheduleCreateWithoutSlotsInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
    instructor: InstructorCreateNestedOneWithoutInstructorSchedulesInput
  }

  export type InstructorScheduleUncheckedCreateWithoutSlotsInput = {
    id?: number
    instructorId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
  }

  export type InstructorScheduleCreateOrConnectWithoutSlotsInput = {
    where: InstructorScheduleWhereUniqueInput
    create: XOR<InstructorScheduleCreateWithoutSlotsInput, InstructorScheduleUncheckedCreateWithoutSlotsInput>
  }

  export type InstructorScheduleUpsertWithoutSlotsInput = {
    update: XOR<InstructorScheduleUpdateWithoutSlotsInput, InstructorScheduleUncheckedUpdateWithoutSlotsInput>
    create: XOR<InstructorScheduleCreateWithoutSlotsInput, InstructorScheduleUncheckedCreateWithoutSlotsInput>
    where?: InstructorScheduleWhereInput
  }

  export type InstructorScheduleUpdateToOneWithWhereWithoutSlotsInput = {
    where?: InstructorScheduleWhereInput
    data: XOR<InstructorScheduleUpdateWithoutSlotsInput, InstructorScheduleUncheckedUpdateWithoutSlotsInput>
  }

  export type InstructorScheduleUpdateWithoutSlotsInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    instructor?: InstructorUpdateOneRequiredWithoutInstructorSchedulesNestedInput
  }

  export type InstructorScheduleUncheckedUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type InstructorCreateWithoutInstructorAbsencesInput = {
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassCreateNestedManyWithoutInstructorInput
  }

  export type InstructorUncheckedCreateWithoutInstructorAbsencesInput = {
    id?: number
    name: string
    email: string
    password: string
    classURL: string
    icon: string
    nickname: string
    meetingId: string
    passcode: string
    createdAt?: Date | string
    birthdate: Date | string
    favoriteFood: string
    hobby: string
    lifeHistory: string
    messageForChildren: string
    skill: string
    workingTime: string
    terminationAt?: Date | string | null
    updatedAt?: Date | string
    isNative: boolean
    classes?: ClassUncheckedCreateNestedManyWithoutInstructorInput
    instructorSchedules?: InstructorScheduleUncheckedCreateNestedManyWithoutInstructorInput
    recurringClasses?: RecurringClassUncheckedCreateNestedManyWithoutInstructorInput
  }

  export type InstructorCreateOrConnectWithoutInstructorAbsencesInput = {
    where: InstructorWhereUniqueInput
    create: XOR<InstructorCreateWithoutInstructorAbsencesInput, InstructorUncheckedCreateWithoutInstructorAbsencesInput>
  }

  export type InstructorUpsertWithoutInstructorAbsencesInput = {
    update: XOR<InstructorUpdateWithoutInstructorAbsencesInput, InstructorUncheckedUpdateWithoutInstructorAbsencesInput>
    create: XOR<InstructorCreateWithoutInstructorAbsencesInput, InstructorUncheckedCreateWithoutInstructorAbsencesInput>
    where?: InstructorWhereInput
  }

  export type InstructorUpdateToOneWithWhereWithoutInstructorAbsencesInput = {
    where?: InstructorWhereInput
    data: XOR<InstructorUpdateWithoutInstructorAbsencesInput, InstructorUncheckedUpdateWithoutInstructorAbsencesInput>
  }

  export type InstructorUpdateWithoutInstructorAbsencesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUpdateManyWithoutInstructorNestedInput
  }

  export type InstructorUncheckedUpdateWithoutInstructorAbsencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    classURL?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    passcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthdate?: DateTimeFieldUpdateOperationsInput | Date | string
    favoriteFood?: StringFieldUpdateOperationsInput | string
    hobby?: StringFieldUpdateOperationsInput | string
    lifeHistory?: StringFieldUpdateOperationsInput | string
    messageForChildren?: StringFieldUpdateOperationsInput | string
    skill?: StringFieldUpdateOperationsInput | string
    workingTime?: StringFieldUpdateOperationsInput | string
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isNative?: BoolFieldUpdateOperationsInput | boolean
    classes?: ClassUncheckedUpdateManyWithoutInstructorNestedInput
    instructorSchedules?: InstructorScheduleUncheckedUpdateManyWithoutInstructorNestedInput
    recurringClasses?: RecurringClassUncheckedUpdateManyWithoutInstructorNestedInput
  }

  export type CustomerCreateWithoutChildrenInput = {
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    classes?: ClassCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutChildrenInput = {
    id?: number
    name: string
    email: string
    password: string
    prefecture: string
    emailVerified?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hasSeenWelcome?: boolean
    terminationAt?: Date | string | null
    classes?: ClassUncheckedCreateNestedManyWithoutCustomerInput
    subscription?: SubscriptionUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutChildrenInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutChildrenInput, CustomerUncheckedCreateWithoutChildrenInput>
  }

  export type ClassAttendanceCreateWithoutChildrenInput = {
    class: ClassCreateNestedOneWithoutClassAttendanceInput
  }

  export type ClassAttendanceUncheckedCreateWithoutChildrenInput = {
    classId: number
  }

  export type ClassAttendanceCreateOrConnectWithoutChildrenInput = {
    where: ClassAttendanceWhereUniqueInput
    create: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput>
  }

  export type ClassAttendanceCreateManyChildrenInputEnvelope = {
    data: ClassAttendanceCreateManyChildrenInput | ClassAttendanceCreateManyChildrenInput[]
    skipDuplicates?: boolean
  }

  export type RecurringClassAttendanceCreateWithoutChildrenInput = {
    recurringClass: RecurringClassCreateNestedOneWithoutRecurringClassAttendanceInput
  }

  export type RecurringClassAttendanceUncheckedCreateWithoutChildrenInput = {
    recurringClassId: number
  }

  export type RecurringClassAttendanceCreateOrConnectWithoutChildrenInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    create: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput>
  }

  export type RecurringClassAttendanceCreateManyChildrenInputEnvelope = {
    data: RecurringClassAttendanceCreateManyChildrenInput | RecurringClassAttendanceCreateManyChildrenInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutChildrenInput = {
    update: XOR<CustomerUpdateWithoutChildrenInput, CustomerUncheckedUpdateWithoutChildrenInput>
    create: XOR<CustomerCreateWithoutChildrenInput, CustomerUncheckedCreateWithoutChildrenInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutChildrenInput, CustomerUncheckedUpdateWithoutChildrenInput>
  }

  export type CustomerUpdateWithoutChildrenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    prefecture?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hasSeenWelcome?: BoolFieldUpdateOperationsInput | boolean
    terminationAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUncheckedUpdateManyWithoutCustomerNestedInput
    subscription?: SubscriptionUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput = {
    where: ClassAttendanceWhereUniqueInput
    update: XOR<ClassAttendanceUpdateWithoutChildrenInput, ClassAttendanceUncheckedUpdateWithoutChildrenInput>
    create: XOR<ClassAttendanceCreateWithoutChildrenInput, ClassAttendanceUncheckedCreateWithoutChildrenInput>
  }

  export type ClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput = {
    where: ClassAttendanceWhereUniqueInput
    data: XOR<ClassAttendanceUpdateWithoutChildrenInput, ClassAttendanceUncheckedUpdateWithoutChildrenInput>
  }

  export type ClassAttendanceUpdateManyWithWhereWithoutChildrenInput = {
    where: ClassAttendanceScalarWhereInput
    data: XOR<ClassAttendanceUpdateManyMutationInput, ClassAttendanceUncheckedUpdateManyWithoutChildrenInput>
  }

  export type RecurringClassAttendanceUpsertWithWhereUniqueWithoutChildrenInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    update: XOR<RecurringClassAttendanceUpdateWithoutChildrenInput, RecurringClassAttendanceUncheckedUpdateWithoutChildrenInput>
    create: XOR<RecurringClassAttendanceCreateWithoutChildrenInput, RecurringClassAttendanceUncheckedCreateWithoutChildrenInput>
  }

  export type RecurringClassAttendanceUpdateWithWhereUniqueWithoutChildrenInput = {
    where: RecurringClassAttendanceWhereUniqueInput
    data: XOR<RecurringClassAttendanceUpdateWithoutChildrenInput, RecurringClassAttendanceUncheckedUpdateWithoutChildrenInput>
  }

  export type RecurringClassAttendanceUpdateManyWithWhereWithoutChildrenInput = {
    where: RecurringClassAttendanceScalarWhereInput
    data: XOR<RecurringClassAttendanceUpdateManyMutationInput, RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenInput>
  }

  export type ClassCreateManyInstructorInput = {
    id?: number
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type InstructorAbsenceCreateManyInstructorInput = {
    absentAt: Date | string
  }

  export type InstructorScheduleCreateManyInstructorInput = {
    id?: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    timezone: string
  }

  export type RecurringClassCreateManyInstructorInput = {
    id?: number
    subscriptionId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
  }

  export type ClassUpdateWithoutInstructorInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutClassesNestedInput
    recurringClass?: RecurringClassUpdateOneWithoutClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutClassNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InstructorAbsenceUpdateWithoutInstructorInput = {
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorAbsenceUncheckedUpdateWithoutInstructorInput = {
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorAbsenceUncheckedUpdateManyWithoutInstructorInput = {
    absentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorScheduleUpdateWithoutInstructorInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    slots?: InstructorSlotUpdateManyWithoutScheduleNestedInput
  }

  export type InstructorScheduleUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    slots?: InstructorSlotUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type InstructorScheduleUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timezone?: StringFieldUpdateOperationsInput | string
  }

  export type RecurringClassUpdateWithoutInstructorInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUpdateManyWithoutRecurringClassNestedInput
    subscription?: SubscriptionUpdateOneWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUncheckedUpdateManyWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateManyWithoutInstructorInput = {
    id?: IntFieldUpdateOperationsInput | number
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChildCreateManyCustomerInput = {
    id?: number
    name: string
    birthdate?: Date | string | null
    personalInfo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassCreateManyCustomerInput = {
    id?: number
    instructorId?: number | null
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type SubscriptionCreateManyCustomerInput = {
    id?: number
    planId: number
    startAt: Date | string
    endAt?: Date | string | null
  }

  export type ChildUpdateWithoutCustomerInput = {
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classAttendance?: ClassAttendanceUpdateManyWithoutChildrenNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenNestedInput
  }

  export type ChildUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpdateWithoutCustomerInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    instructor?: InstructorUpdateOneWithoutClassesNestedInput
    recurringClass?: RecurringClassUpdateOneWithoutClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutClassNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SubscriptionUpdateWithoutCustomerInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUpdateManyWithoutSubscriptionNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUncheckedUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    planId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassAttendanceCreateManyClassInput = {
    childrenId: number
  }

  export type ClassAttendanceUpdateWithoutClassInput = {
    children?: ChildUpdateOneRequiredWithoutClassAttendanceNestedInput
  }

  export type ClassAttendanceUncheckedUpdateWithoutClassInput = {
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassAttendanceUncheckedUpdateManyWithoutClassInput = {
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: number
    customerId: number
    startAt: Date | string
    endAt?: Date | string | null
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUpdateManyWithoutSubscriptionNestedInput
    customer?: CustomerUpdateOneRequiredWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    class?: ClassUncheckedUpdateManyWithoutSubscriptionNestedInput
    recurringClass?: RecurringClassUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassCreateManySubscriptionInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    recurringClassId?: number | null
    dateTime?: Date | string | null
    status: $Enums.Status
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type RecurringClassCreateManySubscriptionInput = {
    id?: number
    instructorId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
  }

  export type ClassUpdateWithoutSubscriptionInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutClassesNestedInput
    instructor?: InstructorUpdateOneWithoutClassesNestedInput
    recurringClass?: RecurringClassUpdateOneWithoutClassesNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    recurringClassId?: NullableIntFieldUpdateOperationsInput | number | null
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecurringClassUpdateWithoutSubscriptionInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUpdateManyWithoutRecurringClassNestedInput
    instructor?: InstructorUpdateOneWithoutRecurringClassesNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classes?: ClassUncheckedUpdateManyWithoutRecurringClassNestedInput
    recurringClassAttendance?: RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassNestedInput
  }

  export type RecurringClassUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClassCreateManyRecurringClassInput = {
    id?: number
    instructorId?: number | null
    customerId: number
    dateTime?: Date | string | null
    status: $Enums.Status
    subscriptionId?: number | null
    rebookableUntil?: Date | string | null
    classCode: string
    createdAt?: Date | string
    updatedAt: Date | string
    isFreeTrial?: boolean
  }

  export type RecurringClassAttendanceCreateManyRecurringClassInput = {
    childrenId: number
  }

  export type ClassUpdateWithoutRecurringClassInput = {
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneRequiredWithoutClassesNestedInput
    instructor?: InstructorUpdateOneWithoutClassesNestedInput
    subscription?: SubscriptionUpdateOneWithoutClassNestedInput
    classAttendance?: ClassAttendanceUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutRecurringClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
    classAttendance?: ClassAttendanceUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateManyWithoutRecurringClassInput = {
    id?: IntFieldUpdateOperationsInput | number
    instructorId?: NullableIntFieldUpdateOperationsInput | number | null
    customerId?: IntFieldUpdateOperationsInput | number
    dateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    subscriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    rebookableUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    classCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFreeTrial?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RecurringClassAttendanceUpdateWithoutRecurringClassInput = {
    children?: ChildUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput
  }

  export type RecurringClassAttendanceUncheckedUpdateWithoutRecurringClassInput = {
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringClassAttendanceUncheckedUpdateManyWithoutRecurringClassInput = {
    childrenId?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleCreateManyEventInput = {
    id?: number
    date: Date | string
  }

  export type ScheduleUpdateWithoutEventInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutEventInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorSlotCreateManyScheduleInput = {
    weekday: number
    startTime: Date | string
  }

  export type InstructorSlotUpdateWithoutScheduleInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorSlotUncheckedUpdateWithoutScheduleInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstructorSlotUncheckedUpdateManyWithoutScheduleInput = {
    weekday?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassAttendanceCreateManyChildrenInput = {
    classId: number
  }

  export type RecurringClassAttendanceCreateManyChildrenInput = {
    recurringClassId: number
  }

  export type ClassAttendanceUpdateWithoutChildrenInput = {
    class?: ClassUpdateOneRequiredWithoutClassAttendanceNestedInput
  }

  export type ClassAttendanceUncheckedUpdateWithoutChildrenInput = {
    classId?: IntFieldUpdateOperationsInput | number
  }

  export type ClassAttendanceUncheckedUpdateManyWithoutChildrenInput = {
    classId?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringClassAttendanceUpdateWithoutChildrenInput = {
    recurringClass?: RecurringClassUpdateOneRequiredWithoutRecurringClassAttendanceNestedInput
  }

  export type RecurringClassAttendanceUncheckedUpdateWithoutChildrenInput = {
    recurringClassId?: IntFieldUpdateOperationsInput | number
  }

  export type RecurringClassAttendanceUncheckedUpdateManyWithoutChildrenInput = {
    recurringClassId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}